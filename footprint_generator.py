#  ===================================================================
#  Source File Name : footprint_generator.py
#  Purpose          : Does the hard work to generate the footprint (from a board)
#  Author           : Alan Milne
#  #
#  This is copyright (C) 2022 to Alan Milne
#  ===================================================================
import os
# import math
# import datetime

# from kiutils.board import *
from kiutils.libraries import *

# from debug_print import *
from user_display_libtable import *
# from user_display_footprint import *
# from Supplemental_Classes import *
from Data_Mover import *


# ==================================================================================================================
def init_footprint(name: str):
    footprint             = Footprint()

    # There actually No point in setting LibraryLink as it's only appropriate in a board file!
    footprint.LibraryLink = name

    # Update to reflect Base Information
    # current date and time
    mydate                = datetime.datetime.now()
    # footprint.version     = str(mydate.strftime("%Y")) + str(mydate.strftime("%m")) + str(mydate.strftime("%d")) # Uncomment if want to use current date!
    # footprint.generator   = "MyGen" # Uncomment if you want to use an alternate generator!

    footprint.version     = "20211014"  # V6 Release date
    footprint.generator   = "pcbnew"
    footprint.description = name + ", generated by 'MyGen' on " + str(mydate.strftime("%d")) + "/" + str(mydate.strftime("%m")) + "/" + str(mydate.strftime("%Y"))

    return footprint


# ==================================================================================================================
def on_outline(item, outline_data):
    status = False

    if isinstance(item, FpLine) or isinstance(item, FpRect) or isinstance(item, FpArc) or \
            isinstance(item, GrLine) or isinstance(item, GrRect) or isinstance(item, GrArc):
        start_x = round(item.start.X, 6)
        start_y = round(item.start.Y, 6)
        end_x   = round(item.end.X, 6)
        end_y   = round(item.end.Y, 6)

        if (start_x == outline_data.top_right.X)   or (start_y == outline_data.top_right.Y) \
                or (end_x   == outline_data.top_right.X)   or (end_y   == outline_data.top_right.Y) \
                or (start_x == outline_data.bottom_left.X) or (start_y == outline_data.bottom_left.Y) \
                or (end_x   == outline_data.bottom_left.X) or (end_y   == outline_data.bottom_left.Y):
            status = True

    elif isinstance(item, FpCircle) or isinstance(item, GrCircle):
        delta_x = item.center.X - item.end.X
        delta_y = item.center.Y - item.end.Y

        radius = math.sqrt((delta_x * delta_x) + (delta_y * delta_y))

        right_edge  = round(item.center.X + radius, 6)
        left_edge   = round(item.center.X - radius, 6)
        top_edge    = round(item.center.Y + radius, 6)
        bottom_edge = round(item.center.Y - radius, 6)

        if (right_edge == outline_data.top_right.X)   or (left_edge == outline_data.top_right.X) \
                or (top_edge   == outline_data.top_right.Y)   or (bottom_edge == outline_data.top_right.Y) \
                or (right_edge == outline_data.bottom_left.X) or (left_edge   == outline_data.bottom_left.X) \
                or (top_edge   == outline_data.bottom_left.Y) or (bottom_edge == outline_data.bottom_left.Y):
            status = True

    elif isinstance(item, FpPoly) or isinstance(item, FpCurve) or isinstance(item, GrPoly) or isinstance(item, GrCurve):
        loop = 0
        start_x: float = 0.0
        start_y: float = 0.0
        end_x:   float = 0.0
        end_y:   float = 0.0

        for coordinate in item.coordinates:
            if loop == 0:
                start_x = coordinate.X
                start_y = coordinate.Y
            else:
                end_x = coordinate.X
                end_y = coordinate.Y

            loop = loop + 1

        if (start_x == outline_data.top_right.X)           or (start_y == outline_data.top_right.Y) \
                or (end_x   == outline_data.top_right.X)   or (end_y   == outline_data.top_right.Y) \
                or (start_x == outline_data.bottom_left.X) or (start_y == outline_data.bottom_left.Y) \
                or (end_y   == outline_data.bottom_left.X) or (end_y   == outline_data.bottom_left.Y):
            status = True

    return status


# ==================================================================================================================
# Get the start and end points for the graphic item
def get_ends(item):
    ends: List() = []

    if isinstance(item, FpLine) or isinstance(item, FpRect) or isinstance(item, FpArc) or \
            isinstance(item, GrLine) or isinstance(item, GrRect) or isinstance(item, GrArc):
        ends.append(item.start)
        ends.append(item.end)

    elif isinstance(item, FpPoly) or isinstance(item, FpCurve) or isinstance(item, GrPoly) or isinstance(item, GrCurve):
        ends.append(item.coordinates[0])
        ends.append(item.coordinates[len(item.coordinates)])

    return ends


# ==================================================================================================================
def connected2outline(item, outline_points):
    status = False

    # Don't need to worry abot text, textbox, polygon or circle - the later two causes they are closed shapes.

    if isinstance(item, FpLine) or isinstance(item, FpRect) or isinstance(item, FpArc):
        for point in outline_points:
            if item.start.X == point.X or item.start.Y == point.Y or item.end.X == point.X or item.end.Y == point.Y:
                status = True

    elif isinstance(item, FpCurve):
        for point in outline_points:
            if item.coordinates[0] == point.X or item.coordinates[0].Y == point.Y or item.coordinates[len(item.coordinates) - 1].X == point.X \
                    or item.coordinates[len(item.coordinates) - 1].Y == point.Y:
                status = True

    return status


# ==================================================================================================================
# Trawls through all the graphic items that are on EdgeCut on the board and copy them to f.fab on footprint
def create_outline(gr_items, outline_data, flip):
    outline_items:     List() = []
    outline_points:    List() = []
    non_outline_items: List() = []

    outline = OutlineData(board_edge     = list(),
                          non_board_edge = list())

    poly_circle_outline = False

    # Trawl for items on the Edge.Cuts lay as they are what we want to use, if used, then convert to fp (from gr)
    # Also want to move to "F.Fab" and set width.
    for gitem in gr_items:
        # ignore if on text or textbox

        if isinstance(gitem, GrLine):
            if gitem.layer == "Edge.Cuts":
                new_start = Position(X        = pt_soff(gitem.start, outline_data.centroid).X,
                                     Y        = pt_soff(gitem.start, outline_data.centroid).Y * flipped(flip),
                                     angle    = gitem.start.angle,
                                     unlocked = gitem.start.unlocked)

                new_end   = Position(X        = pt_soff(gitem.end, outline_data.centroid).X,
                                     Y        = pt_soff(gitem.end, outline_data.centroid).Y * flipped(flip),
                                     angle    = gitem.end.angle,
                                     unlocked = gitem.end.unlocked)

                fitem_fab = FpLine(start  = new_start,
                                   end    = new_end,
                                   layer  = "F.Fab",
                                   width  = 0.1,
                                   stroke = None,
                                   locked = False,
                                   tstamp = gitem.tstamp)

                if on_outline(fitem_fab, outline_data):
                    outline_items.append(fitem_fab)
                    outline_points.extend(get_ends(fitem_fab))

                else:
                    non_outline_items.append(fitem_fab)

        elif isinstance(gitem, GrRect):
            if gitem.layer == "Edge.Cuts":
                new_start = Position(X        = pt_soff(gitem.start, outline_data.centroid).X,
                                     Y        = pt_soff(gitem.start, outline_data.centroid).Y * flipped(flip),
                                     angle    = gitem.start.angle,
                                     unlocked = gitem.start.unlocked)

                new_end   = Position(X        = pt_soff(gitem.end, outline_data.centroid).X,
                                     Y        = pt_soff(gitem.end, outline_data.centroid).Y * flipped(flip),
                                     angle    = gitem.end.angle,
                                     unlocked = gitem.end.unlocked)

                fitem_fab = FpRect(start  = new_start,
                                   end    = new_end,
                                   layer  = "F.Fab",
                                   width  = 0.1,
                                   stroke = None,
                                   fill   = gitem.fill,
                                   locked = False,
                                   tstamp = gitem.tstamp)

                if on_outline(fitem_fab, outline_data):
                    outline_items.append(fitem_fab)
                    outline_points.extend(get_ends(fitem_fab))

                else:
                    non_outline_items.append(fitem_fab)

        elif isinstance(gitem, GrCircle):
            if gitem.layer == "Edge.Cuts":
                new_center = Position(X        = pt_soff(gitem.center, outline_data.centroid).X,
                                      Y        = pt_soff(gitem.center, outline_data.centroid).Y * flipped(flip),
                                      angle    = gitem.center.angle,
                                      unlocked = gitem.center.unlocked)

                new_end    = Position(X        =pt_soff(gitem.end, outline_data.centroid).X,
                                      Y        =pt_soff(gitem.end, outline_data.centroid).Y * flipped(flip),
                                      angle    =gitem.end.angle,
                                      unlocked =gitem.end.unlocked)

                fitem_fab  = FpCircle(center = new_center,
                                      end    = new_end,
                                      layer  = "F.Fab",
                                      width  = 0.1,
                                      stroke = None,
                                      fill   = gitem.fill,
                                      locked = False,
                                      tstamp = gitem.tstamp)

                if on_outline(fitem_fab, outline_data):
                    # Circular outline so nothing else to do, but should move any spurious items to non-outline
                    for item in outline_items:
                        non_outline_items.append(item)

                    outline_items = list()
                    outline_items.append(fitem_fab)

                    poly_circle_outline = True

                else:
                    non_outline_items.append(fitem_fab)

        elif isinstance(gitem, GrArc):
            if gitem.layer == "Edge.Cuts":
                # Need to swap start and end.
                if flip:  # flip
                    start = gitem.end
                    middle = gitem.mid
                    end = gitem.start

                else:    # no flip
                    start = gitem.start
                    middle = gitem.mid
                    end = gitem.end

                # Fab Layer
                new_start = Position(X        = pt_soff(start, outline_data.centroid).X,
                                     Y        = pt_soff(start, outline_data.centroid).Y * flipped(flip),
                                     angle    = start.angle,
                                     unlocked = start.unlocked)

                new_mid   = Position(X        = pt_soff(middle, outline_data.centroid).X,
                                     Y        = pt_soff(middle, outline_data.centroid).Y * flipped(flip),
                                     angle    = middle.angle,
                                     unlocked = middle.unlocked)

                new_end   = Position(X        = pt_soff(end, outline_data.centroid).X,
                                     Y        = pt_soff(end, outline_data.centroid).Y * flipped(flip),
                                     angle    = end.angle,
                                     unlocked = end.unlocked)

                fitem_fab = FpArc(start  = new_start,
                                  mid    = new_mid,
                                  end    = new_end,
                                  layer  = "F.Fab",
                                  width  = gitem.width,
                                  stroke = None,
                                  locked = False,
                                  tstamp = gitem.tstamp)

                if on_outline(fitem_fab, outline_data):
                    outline_items.append(fitem_fab)
                    outline_points.extend(get_ends(fitem_fab))

                else:
                    non_outline_items.append(fitem_fab)

        elif isinstance(gitem, GrPoly):
            if gitem.layer == "Edge.Cuts":
                new_coords = list()

                for coord in gitem.coordinates:
                    new_coords.append(Position(X        = pt_soff(coord, outline_data.centroid).X,
                                               Y        = pt_soff(coord, outline_data.centroid).Y * flipped(flip),
                                               angle    = coord.angle,
                                               unlocked = coord.unlocked))

                fitem_fab = FpPoly(coordinates = new_coords,
                                   layer       = "F.Fab",
                                   width       = 0.1,
                                   stroke      = None,
                                   fill        = gitem.fill,
                                   locked      = False,
                                   tstamp      = gitem.tstamp)

                if on_outline(fitem_fab, outline_data):
                    # Closed Polygon outline so nothing else to do, but should move any spurious items to non-outline
                    for item in outline_items:
                        non_outline_items.append(item)

                    outline_items = list()
                    outline_items.append(fitem_fab)

                    poly_circle_outline = True
                else:
                    non_outline_items.append(fitem_fab)

        elif isinstance(gitem, GrCurve):
            if gitem.layer == "Edge.Cuts":
                # Fab, Silkscreen and Courtyard Layers
                new_coords = list()

                for coord in gitem.coordinates:
                    new_coords.append(Position(X        = pt_soff(coord, outline_data.centroid).X,
                                               Y        = pt_soff(coord, outline_data.centroid).Y * flipped(flip),
                                               angle    = coord.angle,
                                               unlocked = coord.unlocked))

                fitem_fab = FpCurve(coordinates = new_coords,
                                    layer       = "F.Fab",
                                    width       = 0.1,
                                    stroke      = None,
                                    locked      = False,
                                    tstamp      = gitem.tstamp)

                if on_outline(fitem_fab, outline_data):
                    outline_items.append(fitem_fab)
                    outline_points.extend(get_ends(fitem_fab))

                else:
                    non_outline_items.append(fitem_fab)

    if not poly_circle_outline:
        # keep looking for items that are the outline.
        outline_finished = False

        # new look to see if there is anything inside the extents but connects to the outline
        while not outline_finished:
            outline_finished = True

            for item in non_outline_items:
                if connected2outline(item, outline_points):
                    outline_items.append(item)
                    non_outline_items.remove(item)

                    data = get_ends(item)
                    outline_points.extend(data)

                    outline_finished = False

    outline.board_edge     = outline_items
    outline.non_board_edge = non_outline_items

    return outline


# ==================================================================================================================
def select_connectors(footprints, flip):
    menu_data = list()

    for footprint in footprints:

        component_id = None
        component_type = None

        for fitem in footprint.graphicItems:
            if isinstance(fitem, FpText):
                if fitem.type == 'reference':
                    component_id = fitem.text

                elif fitem.type == 'value':
                    component_type = fitem.text

        if (component_id is not None) and (component_type is not None):  # and (footprint.layer == component_layer):
            if footprint.attributes.type is None:
                display_text = "[" + footprint.layer + "] Not Defined    : " + component_id + "/" + component_type
            else:
                if footprint.attributes.type == "smd":
                    display_text = "[" + footprint.layer + "] SMD                 : " + component_id + "/" + component_type
                else:
                    display_text = "[" + footprint.layer + "] Through Hole : " + component_id + "/" + component_type

            menu_data.append(display_text)

    if len(menu_data) > 1:
        # it is helpful to (pre)select the components on the correct side of the board
        preselect = list()
        select_pos = 0

        # sort data to make it easier to select components
        menu_data = sorted(menu_data)

        # Use flip to decide which components are likely to be selected
        for component in menu_data:
            if flip:  # flip
                if component[0:3] == "[F.":
                    preselect.append(select_pos)
            else:  # No flip
                if component[0:3] == "[B.":
                    preselect.append(select_pos)

            select_pos += 1

        # now select the components we want to use
        field_values = multchoicebox(msg="Select the component(s) that you want to appear as pads on the footprint.",
                                     title="Component Selection",
                                     choices=menu_data,
                                     preselect=preselect)
    else:
        field_values = menu_data

    return field_values


# ==================================================================================================================
# Need to check that output directories exist and if not create them.
def manage_lib_dir(odir):
    # We need to create "MyGen.Pretty" so that we can save the footprint and then update the library,
    # but only if it does not exist. Also need to check for a "Shapes_3D" directory and create if necessary.
    # We also need to figure out what 3D files we need copy them if necessary to the "Shapes_3D" file.
    library_exist = os.path.exists(odir + "\\" + "MyGen.Pretty")

    if library_exist:
        shapes_exist = os.path.exists(odir + "\\" + "MyGen.Pretty" + "\\" + "Shapes_3D")

        if not shapes_exist:
            os.makedirs(odir + "\\" + "MyGen.Pretty" + "\\" + "Shapes_3D")

    else:
        os.makedirs(odir + "\\" + "MyGen.Pretty")
        os.makedirs(odir + "\\" + "MyGen.Pretty" + "\\" + "Shapes_3D")

    # now read the library to see if it points to the library "MyGen.Pretty", if not add it
    if path.exists(odir + "\\" + "fp-lib-table"):
        pcb_lib_table = LibTable().from_file(odir + "\\" + "fp-lib-table")

        lib_found = False

        for lib in pcb_lib_table.libs:
            if lib.name == "MyGen":
                lib_found = True

    else:
        # Can't file the "fp-lib-table" so create an empty file!
        pcb_lib_table = LibTable(type="fp_lib_table")
        lib_found = False

    # "MyGen.Pretty" Not found so need to add it
    if not lib_found:
        new_lib = Library()

        new_lib.name        = "MyGen"
        new_lib.type        = "KiCad"
        new_lib.uri         = odir + "\\" + "MyGen.Pretty"
        new_lib.options     = ""
        new_lib.description = ""

        pcb_lib_table.libs.append(new_lib)

        pcb_lib_table.to_file(odir + "\\" + "fp-lib-table")


# ==================================================================================================================
# Need to calculate certain values about the selected footprint so that we can add pads, models, etc. correctly.
def add_component_data(footprints, menu_data, centroid_offset, board_flip):
    component_data = Component()
    aux_data = AuxData()

    aux_data.centroid_offset = centroid_offset
    aux_data.board_flip = board_flip

    for component in menu_data:
        # Need to recover component mount technology, ID and Type
        # component_mount = component[0:component.find(" : ")]

        aux_data.id = component[component.find(" : ") + 3:component.find("/")]
        aux_data.type = component[component.find("/") + 1:len(component)]

        for footprint in footprints:
            id_match = False
            component_match = False
            aux_data.longaxis_x = False
            aux_data.center_origin = False

            for fitem in footprint.graphicItems:
                if isinstance(fitem, FpText):
                    # If text property match the ID then this might be the footprint
                    if fitem.type == 'reference':
                        if fitem.text == aux_data.id:
                            id_match = True

                    # If text property match the TYPE then this might be the footprint
                    elif fitem.type == 'value':
                        if fitem.text == aux_data.type:
                            # if we've also found the ID all is good
                            if id_match:
                                component_match = True
                                break

            # found a selected component, so copy data
            if component_match:
                # need to determine where the pads are to calculate the swap direction and (maybe) the center
                top_right = Coordinate2D()
                bottom_left = Coordinate2D()

                # cycle round the pads to find the center - TODO: this may be better done on via the courtyard layer?
                for pad in footprint.pads:
                    if pad.position.X > top_right.X:
                        top_right.X = pad.position.X

                    if pad.position.Y > top_right.Y:
                        top_right.Y = pad.position.Y

                    if pad.position.X < bottom_left.X:
                        bottom_left.X = pad.position.X

                    if pad.position.Y < bottom_left.Y:
                        bottom_left.Y = pad.position.Y

                # Use LibraryLink to figure out some stuff
                if footprint.attributes.type == "smd":
                    aux_data.center_origin = True

                    # SMD then origin is known!
                    aux_data.center.X = 0.0
                    aux_data.center.Y = 0.0

                    if (top_right.X - bottom_left.X) > (top_right.Y - bottom_left.Y):
                        aux_data.longaxis_x = True

                    else:
                        aux_data.longaxis_x = False

                elif footprint.attributes.type == "through_hole":
                    aux_data.center_origin = False

                    aux_data.center.X = ((top_right.X - bottom_left.X) / 2) + bottom_left.X
                    aux_data.center.Y = ((top_right.Y - bottom_left.Y) / 2) + bottom_left.Y

                    if (top_right.X - bottom_left.X) > (top_right.Y - bottom_left.Y):
                        aux_data.longaxis_x = True

                    else:
                        aux_data.longaxis_x = False

                else:  # anything else (none or other)/
                    aux_data.center.X = ((top_right.X - bottom_left.X) / 2) + bottom_left.X
                    aux_data.center.Y = ((top_right.Y - bottom_left.Y) / 2) + bottom_left.Y

                    if ynbox("Do you want to flip " + aux_data.id + "?", "Flip selection", ["X-Axis", "Y-Axis"]) == 1:
                        aux_data.longaxis_x = True
                    else:
                        aux_data.longaxis_x = False

                # now add the footprints for the components select
                component_data.pads.extend(add_footprint_pads(footprint, aux_data))
                component_data.graphicitems.extend(add_footprint_silkscreen(footprint, aux_data))
                component_data.models.extend(add_footprint_models(footprint, aux_data))

    return component_data


# ==================================================================================================================
# now add the footprint data for the components select
def add_footprint_pads(footprint, aux_data):
    modified_pads = list()

    for pad in footprint.pads:
        # make new pin based on the ID & the original pad number
        new_number = aux_data.id + "-" + pad.number

        if aux_data.board_flip:  # Flip so leave as is
            new_layers = pad.layers
        else:  # No flip so swap layers
            new_layers = []

            for layer in pad.layers:
                if layer.find("F.") == 0:
                    new_layers.append(layer.replace("F.", "B."))
                elif layer.find("B.") == 0:
                    new_layers.append(layer.replace("B.", "F."))
                else:
                    new_layers.append(layer)

        modified_pads.append(Pad(number                = new_number,
                                 type                  = pad.type,
                                 shape                 = pad.shape,
                                 position              = new_coordinate_position(footprint.position, pad.position, aux_data),
                                 locked                = True,
                                 size                  = pad.size,
                                 drill                 = pad.drill,
                                 layers                = new_layers,
                                 property              = None,
                                 removeUnusedLayers    = pad.removeUnusedLayers,
                                 keepEndLayers         = pad.keepEndLayers,
                                 roundrectRatio        = pad.roundrectRatio,
                                 chamferRatio          = pad.chamferRatio,
                                 chamfer               = pad.chamfer,
                                 net                   = None,
                                 tstamp                = pad.tstamp,
                                 pinFunction           = pad.pinFunction,
                                 pinType               = pad.pinType,
                                 dieLength             = pad.dieLength,
                                 solderMaskMargin      = pad.solderMaskMargin,
                                 solderPasteMargin     = pad.solderPasteMargin,
                                 solderPasteMarginRatio= pad.solderPasteMarginRatio,
                                 clearance             = pad.clearance,
                                 zoneConnect           = None,
                                 thermalWidth          = None,
                                 thermalGap            = None,
                                 customPadOptions      = None,
                                 customPadPrimitives   = None))

    # =========================================================================================
    # Debug code - draws a pad at the center
    # modified_pads.append(Pad(number                 = "Center",
    #                          type                   = "smd",
    #                          shape                  = "circle",
    #                          position               = center_position,
    #                          locked                 = True,
    #                          size                   = pad.size,
    #                          drill                  = pad.drill,
    #                          layers                 = pad.layers,
    #                          property               = None,
    #                          removeUnusedLayers     = pad.removeUnusedLayers,
    #                          keepEndLayers          = pad.keepEndLayers,
    #                          roundrectRatio         = pad.roundrectRatio,
    #                          chamferRatio           = pad.chamferRatio,
    #                          chamfer                = pad.chamfer,
    #                          net                    = None,
    #                          tstamp                 = pad.tstamp,
    #                          pinFunction            = pad.pinFunction,
    #                          pinType                = pad.pinType,
    #                          dieLength              = pad.dieLength,
    #                          solderMaskMargin       = pad.solderMaskMargin,
    #                          solderPasteMargin      = pad.solderPasteMargin,
    #                          solderPasteMarginRatio = pad.solderPasteMarginRatio,
    #                          clearance              = pad.clearance,
    #                          zoneConnect            = None,
    #                          thermalWidth           = None,
    #                          thermalGap             = None,
    #                          customPadOptions       = None,
    #                          customPadPrimitives    = None))
    # =========================================================================================

    return modified_pads


# ==================================================================================================================
# now add the footprint data for the components select
def add_footprint_silkscreen(footprint, aux_data):
    modified_items = list()

    for gitem in footprint.graphicItems:
        # Don't need to worry about text and textbox
        if isinstance(gitem, FpLine):
            if (gitem.layer == "F.SilkS") or (gitem.layer == "B.SilkS"):
                if gitem.width < 0.1:
                    gitem.width = 0.1

                # Silkscreen Layer
                modified_items.append(FpLine(start  = new_coordinate_position(footprint.position, gitem.start, aux_data),
                                             end    = new_coordinate_position(footprint.position, gitem.end, aux_data),
                                             layer  = "F.SilkS",
                                             width  = gitem.width,
                                             stroke = None,
                                             locked = True,
                                             tstamp = gitem.tstamp))

        elif isinstance(gitem, FpRect):
            if (gitem.layer == "F.SilkS") or (gitem.layer == "B.SilkS"):
                if gitem.width < 0.1:
                    gitem.width = 0.1

                modified_items.append(FpRect(start  = new_coordinate_position(footprint.position, gitem.start, aux_data),
                                             end    = new_coordinate_position(footprint.position, gitem.end, aux_data),
                                             layer  = "F.SilkS",
                                             width  = gitem.width,
                                             stroke = None,
                                             fill   = gitem.fill,
                                             locked = False,
                                             tstamp = gitem.tstamp))

        elif isinstance(gitem, FpCircle):
            if (gitem.layer == "F.SilkS") or (gitem.layer == "B.SilkS"):
                if gitem.width < 0.1:
                    gitem.width = 0.1

                modified_items.append(FpCircle(center = new_coordinate_position(footprint.position, gitem.center, aux_data),
                                               end    = new_coordinate_position(footprint.position, gitem.end, aux_data),
                                               layer  = "F.SilkS",
                                               width  = gitem.width,
                                               stroke = None,
                                               fill   = gitem.fill,
                                               locked = False,
                                               tstamp = gitem.tstamp))

        elif isinstance(gitem, FpArc):
            if (gitem.layer == "F.SilkS") or (gitem.layer == "B.SilkS"):
                # There is an issue with arc when flipped. The arc is drawing clockwise so a normal arc becomes an inverse arc!
                # Therefor need to swap start and end.
                if aux_data.board_flip:  # flip
                    start = gitem.end
                    middle = gitem.mid
                    end = gitem.start

                else:  # no flip
                    start = gitem.start
                    middle = gitem.mid
                    end = gitem.end

                if gitem.width < 0.1:
                    gitem.width = 0.1

                new_start = Position(X        = pt_soff(start, aux_data.centroid_offset).X,
                                     Y        = pt_soff(start, aux_data.centroid_offset).Y * flipped(aux_data.board_flip),
                                     angle    = start.angle,
                                     unlocked = start.unlocked)

                new_mid   = Position(X        = pt_soff(middle, aux_data.centroid_offset).X,
                                     Y        = pt_soff(middle, aux_data.centroid_offset).Y * flipped(aux_data.board_flip),
                                     angle    = middle.angle,
                                     unlocked = middle.unlocked)

                new_end   = Position(X        = pt_soff(end, aux_data.centroid_offset).X,
                                     Y        = pt_soff(end, aux_data.centroid_offset).Y * flipped(aux_data.board_flip),
                                     angle    = end.angle,
                                     unlocked = end.unlocked)

                modified_items.append(FpArc(start  = new_coordinate_position(footprint.position, new_start, aux_data),
                                            mid    = new_coordinate_position(footprint.position, new_mid, aux_data),
                                            end    = new_coordinate_position(footprint.position, new_end, aux_data),
                                            layer  = "F.SilkS",
                                            width  = gitem.width,
                                            stroke = None,
                                            locked = False,
                                            tstamp = gitem.tstamp))

        elif isinstance(gitem, FpPoly):
            if (gitem.layer == "F.SilkS") or (gitem.layer == "B.SilkS"):
                if gitem.width < 0.1:
                    gitem.width = 0.1

                # Fab, Silkscreen and Courtyard Layers
                new_coords = list()

                for coord in gitem.coordinates:
                    new_coords.append(new_coordinate_position(footprint.position, coord, aux_data))

                modified_items.append(FpPoly(coordinates= new_coords,
                                             layer      = "F.SilkS",
                                             width      = gitem.width,
                                             stroke     = None,
                                             fill       = gitem.fill,
                                             locked     = False,
                                             tstamp     = gitem.tstamp))

        elif isinstance(gitem, FpCurve):
            if (gitem.layer == "F.SilkS") or (gitem.layer == "B.SilkS"):
                if gitem.width < 0.1:
                    gitem.width = 0.1

                new_coords = list()

                for coord in gitem.coordinates:
                    new_coords.append(new_coordinate_position(footprint.position, coord, aux_data))

                modified_items.append(FpCurve(coordinates = new_coords,
                                              layer       = "F.SilkS",
                                              width       = gitem.width,
                                              stroke      = None,
                                              locked      = False,
                                              tstamp      = gitem.tstamp))

    return modified_items


# ==================================================================================================================
# now add the models for the components select
def add_footprint_models(footprint, aux_data):
    modified_models = list()

    for model in footprint.models:
        new_path = model.path

        # We should look for the pointer to KiCAD library then Substitute "PinHeader" with "PinSocket" and vice-versa.
        # This will not work going forward without change!
        # For some we also need to swap "Right and Left"
        if new_path.find("${KICAD6_3DMODEL_DIR} / Connector_"):
            if new_path.find("PinHeader_") >= 0:
                new_path = new_path.replace("PinHeader_", "PinSocket_")
            elif new_path.find("PinSocket_") >= 0:
                new_path = new_path.replace("PinSocket_", "PinHeader_")

            if new_path.find("_Vertical_SMD_Pin1Right.") >= 0:
                new_path = new_path.replace("_Vertical_SMD_Pin1Right", "_Vertical_SMD_Pin1Left")
            elif new_path.find("_Vertical_SMD_Pin1Left.") >= 0:
                new_path = new_path.replace("_Vertical_SMD_Pin1Left", "_Vertical_SMD_Pin1Right")

        # TODO: else:
        # TODO:     # Not one of the libraries we can handle so need to copy file to the "Shapes_3D" directory.

        modified_models.append(new_model_position(footprint.position, model, new_path, aux_data.centroid_offset, aux_data.board_flip))

    return modified_models
