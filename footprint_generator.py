#  ===================================================================
#  Source File Name : footprint_generator.py
#  Purpose          : Does the hard work to generate the footprint (from a board)
#  Author           : Alan Milne
#  #
#  This is copyright (C) 2022 to Alan Milne
#  ===================================================================

import os
import math
# import datetime

# from kiutils.board import *
from kiutils.libraries import *

# from debug_print import *
# from user_display_libtable import *
from user_display_footprint import *
from Supplemental_Classes import *


# ==================================================================================================================
def init_footprint(name: str):
    footprint = Footprint()

    # There actually No point in setting LibraryLink as it's only appropriate in a board file!
    footprint.LibraryLink = name

    # Update to reflect Base Information
    # current date and time
    mydate = datetime.datetime.now()
    # footprint.version     = str(mydate.strftime("%Y")) + str(mydate.strftime("%m")) + str(mydate.strftime("%d")) # Uncomment if want to use current date!
    # footprint.generator   = "MyGen" # Uncomment if you want to use an alternate generator!

    footprint.version = "20211014"  # V6 Release date
    footprint.generator = "pcbnew"
    footprint.description = name + ", generated by 'MyGen' on " + str(mydate.strftime("%d")) + "/" + str(mydate.strftime("%m")) + "/" + str(mydate.strftime("%Y"))

    return footprint


# ==================================================================================================================
def calc_circle(point1, point2, point3):
    circle = Circle()

    # Returns the center and radius of the circle passing the given 3 points.
    # In case the 3 points form a line, returns (None, infinity).
    temp = point2.X ** 2 + point2.Y ** 2
    bc = (point1.X ** 2 + point1.Y ** 2 - temp) / 2
    cd = (temp - point3.X ** 2 - point3.Y ** 2) / 2
    det = (point1.X - point2.X) * (point2.Y - point3.Y) - (point2.X - point3.X) * (point1.Y - point2.Y)

    if abs(det) < 1.0e-10:
        return None

    # Center of circle
    circle.center = Coordinate(X=(bc * (point2.Y - point3.Y) - cd * (point1.Y - point2.Y)) / det,
                               Y=((point1.X - point2.X) * cd - (point2.X - point3.X) * bc) / det)

    circle.radius = ((circle.center.X - point1.X) ** 2 + (circle.center.Y - point1.Y) ** 2) ** 0.5
    return circle


# ==================================================================================================================
# Runs through the graphical items and finds the geometric center.
def find_centroid(gr_items):
    # highjack Position to return the centroid
    centroid = Coordinate(X = 0.0,
                          Y = 0.0,
                          Z = 0.0)

    extends_top_right   = Position(X        = 0.0,
                                   Y        = 0.0,
                                   angle    = 0.0,
                                   unlocked = True)  # If false then this needs processed, otherwise it's the first point.

    extends_bottom_left = Position(X        = 0.0,
                                   Y        = 0.0,
                                   angle    = 0.0,
                                   unlocked = True)  # Just ignore this.

    loop = 1

    for gitem in gr_items:
        radius = 0.0

        top_right   = Position(X        = 0.0,
                               Y        = 0.0,
                               angle    = 0.0,
                               unlocked = True)  # If false then this needs processed, otherwise ignore.

        bottom_left = Position(X        = 0.0,
                               Y        = 0.0,
                               angle    = 0.0,
                               unlocked = True)  # DO not use this so "True" so that it is ignored.

        if isinstance(gitem, GrText):
            if gitem.layer == "Edge.Cuts":
                bottom_left = Position(X        = 0.0,
                                       Y        = 0.0,
                                       angle    = 0.0,
                                       unlocked = True)

                top_right   = Position(X        = 0.0,
                                       Y        = 0.0,
                                       angle    = 0.0,
                                       unlocked = True)  # Can ignore as this does not affect the footprint size

            print("Text    " + str(loop) + " - " + str(bottom_left) + "/" + str(top_right))

        elif isinstance(gitem, GrTextBox):
            if gitem.layer == "Edge.Cuts":
                bottom_left = Position(X        = 0.0,
                                       Y        = 0.0,
                                       angle    = 0.0,
                                       unlocked = True)

                top_right   = Position(X        = 0.0,
                                       Y        = 0.0,
                                       angle    = 0.0,
                                       unlocked = True)  # Can ignore as this does not affect the footprint size

            print("TextBox " + str(loop) + " - " + str(bottom_left) + "/" + str(top_right))

        elif isinstance(gitem, GrLine):
            if gitem.layer == "Edge.Cuts":
                if gitem.start.X > gitem.end.X:
                    top_right.X   = gitem.start.X
                    bottom_left.X = gitem.end.X
                else:
                    top_right.X   = gitem.end.X
                    bottom_left.X = gitem.start.X

                if gitem.start.Y > gitem.end.Y:
                    top_right.Y   = gitem.start.Y
                    bottom_left.Y = gitem.end.Y
                else:
                    top_right.Y   = gitem.end.Y
                    bottom_left.Y = gitem.start.Y

                bottom_left.unlocked = True
                top_right.unlocked   = False

                print("Line    " + str(loop) + " - " + str(bottom_left) + "/" + str(top_right))

        elif isinstance(gitem, GrRect):
            if gitem.layer == "Edge.Cuts":
                if gitem.start.X > gitem.end.X:
                    top_right.X   = gitem.start.X
                    bottom_left.X = gitem.end.X
                else:
                    top_right.X   = gitem.end.X
                    bottom_left.X = gitem.start.X

                if gitem.start.Y > gitem.end.Y:
                    top_right.Y   = gitem.start.Y
                    bottom_left.Y = gitem.end.Y
                else:
                    top_right.Y   = gitem.end.Y
                    bottom_left.Y = gitem.start.Y

                bottom_left.unlocked = True
                top_right.unlocked   = False

                print("Rect    " + str(loop) + " - " + str(bottom_left) + "/" + str(top_right))

        elif isinstance(gitem, GrCircle):
            if gitem.layer == "Edge.Cuts":
                # use Pythagoras to determine the radius
                a = gitem.center.X - gitem.end.X
                b = gitem.center.Y - gitem.end.Y

                radius = math.sqrt(pow(a, 2) + pow(b, 2))

                bottom_left.X        = gitem.center.X - radius
                bottom_left.Y        = gitem.center.Y - radius
                bottom_left.unlocked = True

                top_right.X          = gitem.center.X + radius
                top_right.Y          = gitem.center.Y + radius
                top_right.unlocked   = False

            print("Circle  " + str(loop) + " - " + str(bottom_left) + "/" + str(top_right) + " === " + str(radius) + " - " + str(gitem.center) + "/" + str(gitem.end))

        elif isinstance(gitem, GrArc):
            if gitem.layer == "Edge.Cuts":
                # For simplicity, determine the circle based on the arc and us it!
                point1 = Coordinate(X = gitem.start.X,
                                    Y = gitem.start.Y,
                                    Z = 0.0)

                point2 = Coordinate(X = gitem.mid.X,
                                    Y = gitem.mid.Y,
                                    Z = 0.0)

                point3 = Coordinate(X = gitem.end.X,
                                    Y = gitem.end.Y,
                                    Z = 0.0)

                circle = calc_circle(point1, point2, point3)

                bottom_left.X        = circle.center.X - circle.radius
                bottom_left.Y        = circle.center.Y - circle.radius
                bottom_left.unlocked = True

                top_right.X          = circle.center.X + circle.radius
                top_right.Y          = circle.center.Y + circle.radius
                top_right.unlocked   = False

                print("Arc    " + str(loop) + " - " + str(bottom_left) + "/" + str(top_right))

        elif isinstance(gitem, GrPoly):
            if gitem.layer == "Edge.Cuts":
                bottom_left = Position(X        = gitem.coordinates[0].X,
                                       Y        = gitem.coordinates[0].Y,
                                       angle    = 0.0,
                                       unlocked = True)

                top_right   = Position(X        = gitem.coordinates[0].X,
                                       Y        = gitem.coordinates[0].Y,
                                       angle    = 0.0,
                                       unlocked = False)

                for coord in gitem.coordinates:
                    if coord.X > top_right.X:
                        top_right.X = coord.X

                    elif coord.X < bottom_left.X:
                        bottom_left.X = coord.X

                for coord in gitem.coordinates:
                    if coord.Y > top_right.Y:
                        top_right.Y = coord.Y

                    elif coord.Y < bottom_left.Y:
                        bottom_left.Y = coord.Y

                print("Poly   " + str(loop) + " - " + str(bottom_left) + "/" + str(top_right))

        elif isinstance(gitem, GrCurve):
            if gitem.layer == "Edge.Cuts":
                # Documentation on this is poor and apparently not supported in KiCAD 6
                bottom_left = Position(X        = 0.0,
                                       Y        = 0.0,
                                       angle    = 0.0,
                                       unlocked = True)

                top_right   = Position(X        = 0.0,
                                       Y        = 0.0,
                                       angle    = 0.0,
                                       unlocked =True)  # Can ignore as this does not affect the footprint size

                print("Curve  " + str(loop) + " - " + str(bottom_left) + "/" + str(top_right))

        loop += 1

        if not top_right.unlocked:
            if extends_top_right.unlocked:
                extends_top_right.X        = top_right.X
                extends_top_right.Y        = top_right.Y
                extends_top_right.unlocked = False

                extends_bottom_left.X      = bottom_left.X
                extends_bottom_left.Y      = bottom_left.Y

            else:
                if top_right.X > extends_top_right.X:
                    extends_top_right.X   = top_right.X

                if top_right.Y > extends_top_right.Y:
                    extends_top_right.Y   = top_right.Y

                if bottom_left.X < extends_bottom_left.X:
                    extends_bottom_left.X = bottom_left.X

                if bottom_left.Y < extends_bottom_left.Y:
                    extends_bottom_left.Y = bottom_left.Y

    print("---> " + str(extends_bottom_left) + "/" + str(extends_top_right))

    centroid.X = extends_bottom_left.X + ((extends_top_right.X - extends_bottom_left.X) / 2)
    centroid.Y = extends_bottom_left.Y + ((extends_top_right.Y - extends_bottom_left.Y) / 2)

    print("===> " + str(centroid))

    return centroid


# ==================================================================================================================
# (Simple) Offset the point
def pt_soff(position, centroid_offset):
    pos = Position(X        = position.X - centroid_offset.X,
                   Y        = position.Y - centroid_offset.Y,
                   angle    = position.angle,
                   unlocked = position.unlocked)
    return pos


# ==================================================================================================================
# Returns the multiplication factor base on the value of flip
def flipped(flip):
    if flip:
        return -1
    else:
        return 1


# ==================================================================================================================
# Offset the point, but based on a vector!
# TODO: Could improve this - see https://stackoverflow.com/questions/55948254/scale-contours-up-grow-outward
# This is not a perfect approach as for a rectangle, it grows more in the long direction than in the short.
def pt_coff(position, centroid_offset, layer):
    match layer:
        case "F.CrtYd":
            offset = 2.54  # This is set to 0.1" or 2.54 mm. Can't find anything to say that use of mm is wrong.
        case "F.SilkS":
            offset = 1.5  # This is set to 0.1" or 2.54 mm. Can't find anything to say that use of mm is wrong.
        case _:
            offset = 0.001  # non-zero to make maths work

    # calculate the new position based on the centroid offset
    orig_pos = pt_soff(position, centroid_offset)

    # calculate the distance based on the pos x and Y and Pythagoras
    distance = math.sqrt((orig_pos.X ** 2) + (orig_pos.Y ** 2))

    # determine the new x,y
    new_pos = Position(X        = ((offset / distance) * orig_pos.X) + orig_pos.X,
                       Y        = ((offset / distance) * orig_pos.Y) + orig_pos.Y,
                       angle    = position.angle,
                       unlocked = position.unlocked)
    return new_pos


# ==================================================================================================================
# Trawls through all the graphic items that are on EdgeCut on the board and copy them to f.fab on footprint
def create_outline(gr_items, offset, flip):
    fp_items: List() = []

    for gitem in gr_items:
        fitem_fab = None
        fitem_silk = None
        fitem_cyard = None

        if isinstance(gitem, GrText):
            if gitem.layer == "Edge.Cuts":
                gitem.position.unlocked = True

                if gitem.width < 0.1:
                    gitem.width = 0.1

                # Fab Layer
                new_pos = Position(X=pt_soff(gitem.position, offset).X,
                                   Y=pt_soff(gitem.position, offset).Y * flipped(flip),
                                   angle=gitem.position.angle,
                                   unlocked=gitem.position.unlocked)

                fitem_fab = FpText(type="user",
                                   text=gitem.text,
                                   position=new_pos,
                                   hide=False,
                                   layer="F.Fab",
                                   effects=gitem.effects,
                                   tstamp=gitem.tstamp)

        elif isinstance(gitem, GrTextBox):
            if gitem.layer == "Edge.Cuts":
                gitem.start.unlocked = True
                gitem.end.unlocked = True

                for pt in gitem.pts:
                    pt.unlocked = True

                # Fab Layer
                new_start = Position(X=pt_soff(gitem.start, offset).X,
                                     Y=pt_soff(gitem.start, offset).Y * flipped(flip),
                                     angle=gitem.start.angle,
                                     unlocked=gitem.start.unlocked)

                new_end = Position(X=pt_soff(gitem.end, offset).X,
                                   Y=pt_soff(gitem.end, offset).Y * flipped(flip),
                                   angle=gitem.end.angle,
                                   unlocked=gitem.end.unlocked)

                new_pts = list()

                for pts in gitem.pts:
                    new_pts.append(Position(X=pt_soff(pts, offset).X,
                                            Y=pt_soff(pts, offset).Y * flipped(flip),
                                            angle=pts.angle,
                                            unlocked=pts.unlocked))

                fitem_fab = FpTextBox(locked=False,  # Would like to lock this but does not appear to be supported in KiCad
                                      text=gitem.text,
                                      start=new_start,
                                      end=new_end,
                                      pts=new_pts,
                                      angle=gitem.angle,
                                      layer="F.Fab",
                                      tstamp=gitem.tstamp,
                                      effects=gitem.effects,
                                      stroke=gitem.stroke,
                                      renderCache=gitem.renderCache)

        elif isinstance(gitem, GrLine):
            if gitem.layer == "Edge.Cuts":
                gitem.start.unlocked = True
                gitem.end.unlocked = True

                if gitem.width < 0.1:
                    gitem.width = 0.1

                # Fab Layer
                new_start_1 = Position(X=pt_soff(gitem.start, offset).X,
                                       Y=pt_soff(gitem.start, offset).Y * flipped(flip),
                                       angle=gitem.start.angle,
                                       unlocked=gitem.start.unlocked)

                new_end_1 = Position(X=pt_soff(gitem.end, offset).X,
                                     Y=pt_soff(gitem.end, offset).Y * flipped(flip),
                                     angle=gitem.end.angle,
                                     unlocked=gitem.end.unlocked)

                # Silkscreen Layer
                new_start_2 = Position(X=pt_coff(gitem.start, offset, "F.SilkS").X,
                                       Y=pt_coff(gitem.start, offset, "F.SilkS").Y * flipped(flip),
                                       angle=gitem.start.angle,
                                       unlocked=gitem.start.unlocked)

                new_end_2 = Position(X=pt_coff(gitem.end, offset, "F.SilkS").X,
                                     Y=pt_coff(gitem.end, offset, "F.SilkS").Y * flipped(flip),
                                     angle=gitem.end.angle,
                                     unlocked=gitem.end.unlocked)

                # Courtyard Layer
                new_start_3 = Position(X=pt_coff(gitem.start, offset, "F.CrtYd").X,
                                       Y=pt_coff(gitem.start, offset, "F.CrtYd").Y * flipped(flip),
                                       angle=gitem.start.angle,
                                       unlocked=gitem.start.unlocked)

                new_end_3 = Position(X=pt_coff(gitem.end, offset, "F.CrtYd").X,
                                     Y=pt_coff(gitem.end, offset, "F.CrtYd").Y * flipped(flip),
                                     angle=gitem.end.angle,
                                     unlocked=gitem.end.unlocked)

                fitem_fab = FpLine(start=new_start_1,
                                   end=new_end_1,
                                   layer="F.Fab",
                                   width=gitem.width,
                                   stroke=None,
                                   locked=True,
                                   tstamp=gitem.tstamp)

                fitem_silk = FpLine(start=new_start_2,
                                    end=new_end_2,
                                    layer="F.SilkS",
                                    width=0.1,
                                    stroke=None,
                                    locked=True,
                                    tstamp=gitem.tstamp)

                fitem_cyard = FpLine(start=new_start_3,
                                     end=new_end_3,
                                     layer="F.CrtYd",
                                     width=0.05,
                                     stroke=None,
                                     locked=True,
                                     tstamp=gitem.tstamp)

        elif isinstance(gitem, GrRect):
            if gitem.layer == "Edge.Cuts":
                gitem.start.unlocked = True
                gitem.end.unlocked = True

                if gitem.width < 0.1:
                    gitem.width = 0.1

                # Fab Layer
                new_start_1 = Position(X=pt_soff(gitem.start, offset).X,
                                       Y=pt_soff(gitem.start, offset).Y * flipped(flip),
                                       angle=gitem.start.angle,
                                       unlocked=gitem.start.unlocked)

                new_end_1 = Position(X=pt_soff(gitem.end, offset).X,
                                     Y=pt_soff(gitem.end, offset).Y * flipped(flip),
                                     angle=gitem.end.angle,
                                     unlocked=gitem.end.unlocked)
                # Silkscreen Layer
                new_start_2 = Position(X=pt_coff(gitem.start, offset, "F.SilkS").X,
                                       Y=pt_coff(gitem.start, offset, "F.SilkS").Y * flipped(flip),
                                       angle=gitem.start.angle,
                                       unlocked=gitem.start.unlocked)

                new_end_2 = Position(X=pt_coff(gitem.end, offset, "F.SilkS").X,
                                     Y=pt_coff(gitem.end, offset, "F.SilkS").Y * flipped(flip),
                                     angle=gitem.end.angle,
                                     unlocked=gitem.end.unlocked)

                # Courtyard Layer
                new_start_3 = Position(X=pt_coff(gitem.start, offset, "F.CrtYd").X,
                                       Y=pt_coff(gitem.start, offset, "F.CrtYd").Y * flipped(flip),
                                       angle=gitem.start.angle,
                                       unlocked=gitem.start.unlocked)

                new_end_3 = Position(X=pt_coff(gitem.end, offset, "F.CrtYd").X,
                                     Y=pt_coff(gitem.end, offset, "F.CrtYd").Y * flipped(flip),
                                     angle=gitem.end.angle,
                                     unlocked=gitem.end.unlocked)

                fitem_fab = FpRect(start=new_start_1,
                                   end=new_end_1,
                                   layer="F.Fab",
                                   width=gitem.width,
                                   stroke=None,
                                   fill=gitem.fill,
                                   locked=False,  # Would like to lock this but does not appear to be supported in KiCad,
                                   tstamp=gitem.tstamp)

                fitem_silk = FpRect(start=new_start_2,
                                    end=new_end_2,
                                    layer="F.SilkS",
                                    width=0.1,
                                    stroke=None,
                                    fill=gitem.fill,
                                    locked=False,  # Would like to lock this but does not appear to be supported in KiCad,
                                    tstamp=gitem.tstamp)

                fitem_cyard = FpRect(start=new_start_3,
                                     end=new_end_3,
                                     layer="F.CrtYd",
                                     width=0.05,
                                     stroke=None,
                                     fill=gitem.fill,
                                     locked=False,  # Would like to lock this but does not appear to be supported in KiCad,
                                     tstamp=gitem.tstamp)

        elif isinstance(gitem, GrCircle):
            if gitem.layer == "Edge.Cuts":
                gitem.center.unlocked = True
                gitem.end.unlocked = True

                if gitem.width < 0.1:
                    gitem.width = 0.1

                # Fab Layer
                new_center_1 = Position(X=pt_soff(gitem.center, offset).X,
                                        Y=pt_soff(gitem.center, offset).Y * flipped(flip),
                                        angle=gitem.center.angle,
                                        unlocked=gitem.center.unlocked)

                new_end_1 = Position(X=pt_soff(gitem.end, offset).X,
                                     Y=pt_soff(gitem.end, offset).Y * flipped(flip),
                                     angle=gitem.end.angle,
                                     unlocked=gitem.end.unlocked)

                # Silkscreen Layer
                new_center_2 = Position(X=pt_soff(gitem.center, offset).X,
                                        Y=pt_soff(gitem.center, offset).Y * flipped(flip),
                                        angle=gitem.center.angle,
                                        unlocked=gitem.center.unlocked)

                new_end_2 = Position(X=pt_coff(gitem.end, offset, "F.SilkS").X,
                                     Y=pt_coff(gitem.end, offset, "F.SilkS").Y * flipped(flip),
                                     angle=gitem.end.angle,
                                     unlocked=gitem.end.unlocked)

                # Courtyard Layer
                new_center_3 = Position(X=pt_soff(gitem.center, offset).X,
                                        Y=pt_soff(gitem.center, offset).Y * flipped(flip),
                                        angle=gitem.center.angle,
                                        unlocked=gitem.center.unlocked)

                new_end_3 = Position(X=pt_coff(gitem.end, offset, "F.CrtYd").X,
                                     Y=pt_coff(gitem.end, offset, "F.CrtYd").Y * flipped(flip),
                                     angle=gitem.end.angle,
                                     unlocked=gitem.end.unlocked)

                fitem_fab = FpCircle(center=new_center_1,
                                     end=new_end_1,
                                     layer="F.Fab",
                                     width=gitem.width,
                                     stroke=None,
                                     fill=gitem.fill,
                                     locked=False,  # Would like to lock this but does not appear to be supported in KiCad
                                     tstamp=gitem.tstamp)

                fitem_silk = FpCircle(center=new_center_2,
                                      end=new_end_2,
                                      layer="F.SilkS",
                                      width=0.1,
                                      stroke=None,
                                      fill=gitem.fill,
                                      locked=False,  # Would like to lock this but does not appear to be supported in KiCad
                                      tstamp=gitem.tstamp)

                fitem_cyard = FpCircle(center=new_center_3,
                                       end=new_end_3,
                                       layer="F.CrtYd",
                                       width=0.05,
                                       stroke=None,
                                       fill=gitem.fill,
                                       locked=False,  # Would like to lock this but does not appear to be supported in KiCad
                                       tstamp=gitem.tstamp)

        elif isinstance(gitem, GrArc):
            if gitem.layer == "Edge.Cuts":
                gitem.start.unlocked = True
                gitem.mid.unlocked = True
                gitem.end.unlocked = True

                # There is an issue with arc when flipped. The arc is drawing clockwise so a normal arc becomes an inverse arc!
                # Therefor need to swap start and end.
                if flip:  # flip
                    start = gitem.end
                    middle = gitem.mid
                    end = gitem.start

                else:  # no flip
                    start = gitem.start
                    middle = gitem.mid
                    end = gitem.end

                if gitem.width < 0.1:
                    gitem.width = 0.1

                # Fab Layer
                new_start_1 = Position(X=pt_soff(start, offset).X,
                                       Y=pt_soff(start, offset).Y * flipped(flip),
                                       angle=start.angle,
                                       unlocked=start.unlocked)

                new_mid_1 = Position(X=pt_soff(middle, offset).X,
                                     Y=pt_soff(middle, offset).Y * flipped(flip),
                                     angle=middle.angle,
                                     unlocked=middle.unlocked)

                new_end_1 = Position(X=pt_soff(end, offset).X,
                                     Y=pt_soff(end, offset).Y * flipped(flip),
                                     angle=end.angle,
                                     unlocked=end.unlocked)

                # Silkscreen Layer
                new_start_2 = Position(X=pt_coff(start, offset, "F.SilkS").X,
                                       Y=pt_coff(start, offset, "F.SilkS").Y * flipped(flip),
                                       angle=start.angle,
                                       unlocked=start.unlocked)

                new_mid_2 = Position(X=pt_coff(middle, offset, "F.SilkS").X,
                                     Y=pt_coff(middle, offset, "F.SilkS").Y * flipped(flip),
                                     angle=middle.angle,
                                     unlocked=middle.unlocked)

                new_end_2 = Position(X=pt_coff(end, offset, "F.SilkS").X,
                                     Y=pt_coff(end, offset, "F.SilkS").Y * flipped(flip),
                                     angle=end.angle,
                                     unlocked=end.unlocked)

                # Courtyard Layer
                new_start_3 = Position(X=pt_coff(start, offset, "F.CrtYd").X,
                                       Y=pt_coff(start, offset, "F.CrtYd").Y * flipped(flip),
                                       angle=start.angle,
                                       unlocked=start.unlocked)

                new_mid_3 = Position(X=pt_coff(middle, offset, "F.CrtYd").X,
                                     Y=pt_coff(middle, offset, "F.CrtYd").Y * flipped(flip),
                                     angle=middle.angle,
                                     unlocked=middle.unlocked)

                new_end_3 = Position(X=pt_coff(end, offset, "F.CrtYd").X,
                                     Y=pt_coff(end, offset, "F.CrtYd").Y * flipped(flip),
                                     angle=end.angle,
                                     unlocked=end.unlocked)

                fitem_fab = FpArc(start=new_start_1,
                                  mid=new_mid_1,
                                  end=new_end_1,
                                  layer="F.Fab",
                                  width=gitem.width,
                                  stroke=None,
                                  locked=False,  # Would like to lock this but does not appear to be supported in KiCad
                                  tstamp=gitem.tstamp)

                fitem_silk = FpArc(start=new_start_2,
                                   mid=new_mid_2,
                                   end=new_end_2,
                                   layer="F.SilkS",
                                   width=0.1,
                                   stroke=None,
                                   locked=False,  # Would like to lock this but does not appear to be supported in KiCad
                                   tstamp=gitem.tstamp)

                fitem_cyard = FpArc(start=new_start_3,
                                    mid=new_mid_3,
                                    end=new_end_3,
                                    layer="F.CrtYd",
                                    width=0.05,
                                    stroke=None,
                                    locked=False,  # Would like to lock this but does not appear to be supported in KiCad
                                    tstamp=gitem.tstamp)

        elif isinstance(gitem, GrPoly):
            if gitem.layer == "Edge.Cuts":
                for coord in gitem.coordinates:
                    coord.unlocked = True

                if gitem.width < 0.1:
                    gitem.width = 0.1

                # Fab, Silkscreen and Courtyard Layers
                new_coords_1 = list()
                new_coords_2 = list()
                new_coords_3 = list()

                for coord in gitem.coordinates:
                    new_coords_1.append(Position(X=pt_soff(coord, offset).X,
                                                 Y=pt_soff(coord, offset).Y * flipped(flip),
                                                 angle=coord.angle,
                                                 unlocked=coord.unlocked))

                    new_coords_2.append(Position(X=pt_coff(coord, offset, "F.SilkS").X,
                                                 Y=pt_coff(coord, offset, "F.SilkS").Y * flipped(flip),
                                                 angle=coord.angle,
                                                 unlocked=coord.unlocked))

                    new_coords_3.append(Position(X=pt_coff(coord, offset, "F.CrtYd").X,
                                                 Y=pt_coff(coord, offset, "F.CrtYd").Y * flipped(flip),
                                                 angle=coord.angle,
                                                 unlocked=coord.unlocked))

                fitem_fab = FpPoly(layer="F.Fab",
                                   coordinates=new_coords_1,
                                   width=gitem.width,
                                   stroke=None,
                                   fill=gitem.fill,
                                   locked=False,  # Would like to lock this but does not appear to be supported in KiCad
                                   tstamp=gitem.tstamp)

                fitem_silk = FpPoly(layer="F.SilkS",
                                    coordinates=new_coords_2,
                                    width=0.1,
                                    stroke=None,
                                    fill=gitem.fill,
                                    locked=False,  # Would like to lock this but does not appear to be supported in KiCad
                                    tstamp=gitem.tstamp)

                fitem_cyard = FpPoly(layer="F.CrtYd",
                                     coordinates=new_coords_3,
                                     width=0.05,
                                     stroke=None,
                                     fill=gitem.fill,
                                     locked=False,  # Would like to lock this but does not appear to be supported in KiCad
                                     tstamp=gitem.tstamp)

        elif isinstance(gitem, GrCurve):
            if gitem.layer == "Edge.Cuts":
                for coord in gitem.coordinates:
                    coord.unlocked = True

                if gitem.width < 0.1:
                    gitem.width = 0.1

                # Fab, Silkscreen and Courtyard Layers
                new_coords_1 = list()
                new_coords_2 = list()
                new_coords_3 = list()

                for coord in gitem.coordinates:
                    new_coords_1.append(Position(X=pt_soff(coord, offset).X,
                                                 Y=pt_soff(coord, offset).Y * flipped(flip),
                                                 angle=coord.angle,
                                                 unlocked=coord.unlocked))

                    new_coords_2.append(Position(X=pt_coff(coord, offset, "F.SilkS").X,
                                                 Y=pt_coff(coord, offset, "F.SilkS").Y * flipped(flip),
                                                 angle=coord.angle,
                                                 unlocked=coord.unlocked))

                    new_coords_3.append(Position(X=pt_coff(coord, offset, "F.CrtYd").X,
                                                 Y=pt_coff(coord, offset, "F.CrtYd").Y * flipped(flip),
                                                 angle=coord.angle,
                                                 unlocked=coord.unlocked))

                fitem_fab = FpCurve(coordinates=new_coords_1,
                                    layer="F.Fab",
                                    width=gitem.width,
                                    stroke=None,
                                    locked=False,  # Would like to lock this but does not appear to be supported in KiCad
                                    tstamp=gitem.tstamp)

                fitem_silk = FpCurve(coordinates=new_coords_2,
                                     layer="F.SilkS",
                                     width=0.1,
                                     stroke=None,
                                     locked=False,  # Would like to lock this but does not appear to be supported in KiCad
                                     tstamp=gitem.tstamp)

                fitem_cyard = FpCurve(coordinates=new_coords_3,
                                      layer="F.CrtYd",
                                      width=0.05,
                                      stroke=None,
                                      locked=False,  # Would like to lock this but does not appear to be supported in KiCad
                                      tstamp=gitem.tstamp)

        if fitem_fab is not None:
            # add footprint outline
            fp_items.append(fitem_fab)

        if fitem_silk is not None:
            # having added the footprint outline, need to add the same data to the silkscreen layer
            fp_items.append(fitem_silk)

        if fitem_cyard is not None:
            # having added the footprint outline, need to add the same data to the Courtyard layer
            fp_items.append(fitem_cyard)

    return fp_items


# ==================================================================================================================
def select_connectors(footprints, flip):
    menu_data = list()

    for footprint in footprints:

        component_id = None
        component_type = None

        for fitem in footprint.graphicItems:
            if isinstance(fitem, FpText):
                if fitem.type == 'reference':
                    component_id = fitem.text

                elif fitem.type == 'value':
                    component_type = fitem.text

        if (component_id is not None) and (component_type is not None):  # and (footprint.layer == component_layer):
            if footprint.attributes.type is None:
                display_text = "[" + footprint.layer + "] Not Defined    : " + component_id + "/" + component_type
            else:
                if footprint.attributes.type == "smd":
                    display_text = "[" + footprint.layer + "] SMD                 : " + component_id + "/" + component_type
                else:
                    display_text = "[" + footprint.layer + "] Through Hole : " + component_id + "/" + component_type

            menu_data.append(display_text)

    if len(menu_data) > 1:
        # it is helpful to (pre)select the components on the correct side of the board
        preselect = list()
        select_pos = 0

        # sort data to make it easier to select components
        menu_data = sorted(menu_data)

        # Use flip to decide which components are likely to be selected
        for component in menu_data:
            if flip:  # flip
                if component[0:3] == "[F.":
                    preselect.append(select_pos)
            else:  # No flip
                if component[0:3] == "[B.":
                    preselect.append(select_pos)

            select_pos += 1

        # now select the components we want to use
        field_values = multchoicebox(msg="Select the component(s) that you want to appear as pads on the footprint.",
                                     title="Component Selection",
                                     choices=menu_data,
                                     preselect=preselect)
    else:
        field_values = menu_data

    return field_values


# ==================================================================================================================
# Need to check that output directories exist and if not create them.
def manage_lib_dir(odir):

    # We need to create "MyGen.Pretty" so that we can save the footprint and then update the library,
    # but only if it does not exist. Also need to check for a "Shapes_3D" directory and create if necessary.
    # We also need to figure out what 3D files we need copy them if necessary to the "Shapes_3D" file.
    library_exist = os.path.exists(odir + "\\" + "MyGen.Pretty")

    if library_exist:
        shapes_exist = os.path.exists(odir + "\\" + "MyGen.Pretty" + "\\" + "Shapes_3D")

        if not shapes_exist:
            os.makedirs(odir + "\\" + "MyGen.Pretty" + "\\" + "Shapes_3D")

    else:
        os.makedirs(odir + "\\" + "MyGen.Pretty")
        os.makedirs(odir + "\\" + "MyGen.Pretty" + "\\" + "Shapes_3D")

    # now read the library to see if it points to the library "MyGen.Pretty", if not add it
    if path.exists(odir + "\\" + "fp-lib-table"):
        pcb_lib_table = LibTable().from_file(odir + "\\" + "fp-lib-table")

        lib_found = False

        for lib in pcb_lib_table.libs:
            if lib.name == "MyGen":
                lib_found = True

    else:
        # Can't file the "fp-lib-table" so create an empty file!
        pcb_lib_table = LibTable(type = "fp_lib_table")
        lib_found = False

    # "MyGen.Pretty" Not found so need to add it
    if not lib_found:
        new_lib = Library()

        new_lib.name = "MyGen"
        new_lib.type = "KiCad"
        new_lib.uri = odir + "\\" + "MyGen.Pretty"
        new_lib.options = ""
        new_lib.description = ""

        pcb_lib_table.libs.append(new_lib)

        pcb_lib_table.to_file(odir + "\\" + "fp-lib-table")


# ==================================================================================================================
# Need to calculate certain values about the selected footprint so that we can add pads, models, etc. correctly.
def add_component_data(footprints, menu_data, centroid_offset, board_flip):
    component_data = Component()
    aux_data       = AuxData()

    aux_data.centroid_offset = centroid_offset
    aux_data.board_flip      = board_flip

    for component in menu_data:
        # Need to recover component mount technology, ID and Type
        # component_mount = component[0:component.find(" : ")]

        aux_data.id   = component[component.find(" : ") + 3:component.find("/")]
        aux_data.type = component[component.find("/") + 1:len(component)]

        for footprint in footprints:
            id_match               = False
            component_match        = False
            aux_data.longaxis_x    = False
            aux_data.center_origin = False

            for fitem in footprint.graphicItems:
                if isinstance(fitem, FpText):
                    # If text property match the ID then this might be the footprint
                    if fitem.type == 'reference':
                        if fitem.text == aux_data.id:
                            id_match = True

                    # If text property match the TYPE then this might be the footprint
                    elif fitem.type == 'value':
                        if fitem.text == aux_data.type:
                            # if we've also found the ID all is good
                            if id_match:
                                component_match = True
                                break

            # found a selected component, so copy data
            if component_match:
                # need to determine where the pads are to calculate the swap direction and (maybe) the center
                top_right   = Coordinate2D()
                bottom_left = Coordinate2D()

                # cycle round the pads to find the center - TODO: this may be better done on via the courtyard layer?
                for pad in footprint.pads:
                    if pad.position.X > top_right.X:
                        top_right.X = pad.position.X

                    if pad.position.Y > top_right.Y:
                        top_right.Y = pad.position.Y

                    if pad.position.X < bottom_left.X:
                        bottom_left.X = pad.position.X

                    if pad.position.Y < bottom_left.Y:
                        bottom_left.Y = pad.position.Y

                # Use LibraryLink to figure out some stuff
                if footprint.attributes.type == "smd":
                    aux_data.center_origin = True

                    # SMD then origin is known!
                    aux_data.center.X = 0.0
                    aux_data.center.Y = 0.0

                    if (top_right.X - bottom_left.X) > (top_right.Y - bottom_left.Y):
                        aux_data.longaxis_x = True

                    else:
                        aux_data.longaxis_x = False

                elif footprint.attributes.type == "through_hole":
                    aux_data.center_origin = False

                    aux_data.center.X = ((top_right.X - bottom_left.X) / 2) + bottom_left.X
                    aux_data.center.Y = ((top_right.Y - bottom_left.Y) / 2) + bottom_left.Y

                    if (top_right.X - bottom_left.X) > (top_right.Y - bottom_left.Y):
                        aux_data.longaxis_x = True

                    else:
                        aux_data.longaxis_x = False

                else:   # anything else (none or other)/
                    aux_data.center.X = ((top_right.X - bottom_left.X) / 2) + bottom_left.X
                    aux_data.center.Y = ((top_right.Y - bottom_left.Y) / 2) + bottom_left.Y

                    if ynbox("Do you want to flip " + aux_data.id + "?", "Flip selection", ["X-Axis", "Y-Axis"]) == 1:
                        aux_data.longaxis_x = True
                    else:
                        aux_data.longaxis_x = False

                # now add the footprints for the components select
                component_data.pads.extend(add_footprint_pads(footprint, aux_data))
                component_data.models.extend(add_footprint_models(footprint, aux_data))

    return component_data


# ==================================================================================================================
# now add the footprint data for the components select
def add_footprint_pads(footprint, aux_data):
    modified_pads   = list()

    for pad in footprint.pads:
        # make new pin based on the ID & the original pad number
        new_number = aux_data.id + "-" + pad.number

        if aux_data.board_flip:  # Flip so leave as is
            new_layers = pad.layers
        else:                    # No flip so swap layers
            new_layers = list()

            for layer in pad.layers:
                if layer.find("F.") == 0:
                    new_layers.append(layer.replace("F.", "B."))
                elif layer.find("B.") == 0:
                    new_layers.append(layer.replace("B.", "F."))
            else:
                new_layers.append(layer)

        # update position based on having moved the centroid to 0,0
        position = pt_soff(footprint.position, aux_data.centroid_offset)

        center_position = Position()
        new_position    = Position()
        delta           = Position()
        final_pos       = Position()

        # Deal with rotation and offset on pad
        match footprint.position.angle:
            case 90.0:
                new_position.X = (position.X + aux_data.center.Y)
                new_position.Y = (position.Y - aux_data.center.X)

                if aux_data.board_flip:
                    center_position.X = (position.X + aux_data.center.Y)
                    center_position.Y = (position.Y - aux_data.center.X) * flipped(aux_data.board_flip)
                else:
                    center_position.X = (position.X + aux_data.center.Y)
                    center_position.Y = (position.Y - aux_data.center.X)

                delta.X = pad.position.X - aux_data.center.X
                delta.Y = pad.position.Y - aux_data.center.Y

                if aux_data.board_flip:
                    final_pos.X     = (new_position.X + delta.Y)
                    final_pos.Y     = (new_position.Y - delta.X) * flipped(aux_data.board_flip)
                    final_pos.angle = position.angle
                else:
                    final_pos.X     = (new_position.X + delta.Y)
                    final_pos.Y     = (new_position.Y - delta.X)
                    final_pos.angle = position.angle

            case -90.0:
                new_position.X = (position.X - aux_data.center.Y)
                new_position.Y = (position.Y + aux_data.center.X)

                if aux_data.board_flip:
                    center_position.X = (position.X - aux_data.center.Y)
                    center_position.Y = (position.Y + aux_data.center.X) * flipped(aux_data.board_flip)
                else:
                    center_position.X = (position.X - aux_data.center.Y)
                    center_position.Y = (position.Y + aux_data.center.X)

                delta.X = pad.position.X - aux_data.center.X
                delta.Y = pad.position.Y - aux_data.center.Y

                if aux_data.board_flip:
                    final_pos.X     = (new_position.X - delta.Y)
                    final_pos.Y     = (new_position.Y + delta.X) * flipped(aux_data.board_flip)
                    final_pos.angle = position.angle
                else:
                    final_pos.X     = (new_position.X - delta.Y)
                    final_pos.Y     = (new_position.Y + delta.X)
                    final_pos.angle = position.angle

            case 180.0:
                new_position.X = (position.X - aux_data.center.X)
                new_position.Y = (position.Y - aux_data.center.Y)

                if aux_data.board_flip:
                    center_position.X = (position.X - aux_data.center.X)
                    center_position.Y = (position.Y - aux_data.center.Y) * flipped(aux_data.board_flip)
                else:
                    center_position.X = (position.X - aux_data.center.X)
                    center_position.Y = (position.Y - aux_data.center.Y)

                delta.X = pad.position.X - aux_data.center.X
                delta.Y = pad.position.Y - aux_data.center.Y

                if aux_data.board_flip:
                    final_pos.X     = (new_position.X - delta.X)
                    final_pos.Y     = (new_position.Y - delta.Y) * flipped(aux_data.board_flip)
                    final_pos.angle = position.angle
                else:
                    final_pos.X     = (new_position.X - delta.X)
                    final_pos.Y     = (new_position.Y - delta.Y)
                    final_pos.angle = position.angle

            case _:  # angle is 0.0
                new_position.X = (position.X + aux_data.center.X)
                new_position.Y = (position.Y + aux_data.center.Y)

                if aux_data.board_flip:
                    center_position.X = (position.X + aux_data.center.X)
                    center_position.Y = (position.Y + aux_data.center.Y) * flipped(aux_data.board_flip)
                else:
                    center_position.X = (position.X + aux_data.center.X)
                    center_position.Y = (position.Y + aux_data.center.Y)

                delta.X = pad.position.X - aux_data.center.X
                delta.Y = pad.position.Y - aux_data.center.Y

                if aux_data.board_flip:
                    final_pos.X     = (new_position.X + delta.X)
                    final_pos.Y     = (new_position.Y + delta.Y) * flipped(aux_data.board_flip)
                    final_pos.angle = position.angle
                else:
                    final_pos.X     = (new_position.X + delta.X)
                    final_pos.Y     = (new_position.Y + delta.Y)
                    final_pos.angle = position.angle

        modified_pads.append(Pad(number                 = new_number,
                                 type                   = pad.type,
                                 shape                  = pad.shape,
                                 position               = final_pos,
                                 locked                 = True,
                                 size                   = pad.size,
                                 drill                  = pad.drill,
                                 layers                 = new_layers,
                                 property               = None,
                                 removeUnusedLayers     = pad.removeUnusedLayers,
                                 keepEndLayers          = pad.keepEndLayers,
                                 roundrectRatio         = pad.roundrectRatio,
                                 chamferRatio           = pad.chamferRatio,
                                 chamfer                = pad.chamfer,
                                 net                    = None,
                                 tstamp                 = pad.tstamp,
                                 pinFunction            = pad.pinFunction,
                                 pinType                = pad.pinType,
                                 dieLength              = pad.dieLength,
                                 solderMaskMargin       = pad.solderMaskMargin,
                                 solderPasteMargin      = pad.solderPasteMargin,
                                 solderPasteMarginRatio = pad.solderPasteMarginRatio,
                                 clearance              = pad.clearance,
                                 zoneConnect            = None,
                                 thermalWidth           = None,
                                 thermalGap             = None,
                                 customPadOptions       = None,
                                 customPadPrimitives    = None))

    # =========================================================================================
    # Debug code - draws a pad at the center
    # modified_pads.append(Pad(number                 = "Center",
    #                          type                   = "smd",
    #                          shape                  = "circle",
    #                          position               = center_position,
    #                          locked                 = True,
    #                          size                   = pad.size,
    #                          drill                  = pad.drill,
    #                          layers                 = pad.layers,
    #                          property               = None,
    #                          removeUnusedLayers     = pad.removeUnusedLayers,
    #                          keepEndLayers          = pad.keepEndLayers,
    #                          roundrectRatio         = pad.roundrectRatio,
    #                          chamferRatio           = pad.chamferRatio,
    #                          chamfer                = pad.chamfer,
    #                          net                    = None,
    #                          tstamp                 = pad.tstamp,
    #                          pinFunction            = pad.pinFunction,
    #                          pinType                = pad.pinType,
    #                          dieLength              = pad.dieLength,
    #                          solderMaskMargin       = pad.solderMaskMargin,
    #                          solderPasteMargin      = pad.solderPasteMargin,
    #                          solderPasteMarginRatio = pad.solderPasteMarginRatio,
    #                          clearance              = pad.clearance,
    #                          zoneConnect            = None,
    #                          thermalWidth           = None,
    #                          thermalGap             = None,
    #                          customPadOptions       = None,
    #                          customPadPrimitives    = None))
    # =========================================================================================

    return modified_pads


# ==================================================================================================================
# now add the models for the components select
def add_footprint_models(footprint, aux_data):
    modified_models = list()

    for model in footprint.models:
        new_path = model.path

        # update position based on having moved the centroid to 0,0
        position = pt_soff(footprint.position, aux_data.centroid_offset)

        # We should look for the pointer to KiCAD library then Substitute "PinHeader" with "PinSocket" and vice-versa.
        # This will not work going forward without change!
        # For some we also need to swap "Right and Left"
        if new_path.find("${KICAD6_3DMODEL_DIR} / Connector_"):
            if new_path.find("PinHeader_") >= 0:
                new_path = new_path.replace("PinHeader_", "PinSocket_")
            elif new_path.find("PinSocket_") >= 0:
                new_path = new_path.replace("PinSocket_", "PinHeader_")

            if new_path.find("_Vertical_SMD_Pin1Right.") >= 0:
                new_path = new_path.replace("_Vertical_SMD_Pin1Right", "_Vertical_SMD_Pin1Left")
            elif new_path.find("_Vertical_SMD_Pin1Left.") >= 0:
                new_path = new_path.replace("_Vertical_SMD_Pin1Left", "_Vertical_SMD_Pin1Right")
        # TODO: else:
        # TODO:     # Not one of the libraries we can handle so need to copy file to the "Shapes_3D" directory.

        # Deal with rotation and offset on pad
        match footprint.position.angle:
            case 90.0:
                if aux_data.board_flip:
                    new_rotation = model.rotate.Z - 90
                else:
                    new_rotation = model.rotate.Z + 90

                new_model = Model(path   = new_path,
                                  pos    = Coordinate(X =  position.X,                                       # + model.pos.Y * flip.X),
                                                      Y = (position.Y * flipped(aux_data.board_flip)) * -1,  # - model.pos.X * flip.Y),
                                                      Z =  model.pos.Z),
                                  scale  = model.scale,
                                  rotate = Coordinate(X = model.rotate.X,
                                                      Y = model.rotate.Y,
                                                      Z = new_rotation))  # footprint.position.angle)

            case 180.0:
                if aux_data.board_flip:
                    new_rotation = model.rotate.Z + 0
                else:
                    new_rotation = model.rotate.Z + 0

                new_model = Model(path   = new_path,
                                  pos    = Coordinate(X =  position.X,                                       # + model.pos.Y * flip.X),
                                                      Y = (position.Y * flipped(aux_data.board_flip)) * -1,  # - model.pos.X * flip.Y),
                                                      Z =  model.pos.Z),
                                  scale  = model.scale,
                                  rotate = Coordinate(X = model.rotate.X,
                                                      Y = model.rotate.Y,
                                                      Z = new_rotation))  # footprint.position.angle)

            case -90.0:
                if aux_data.board_flip:
                    new_rotation = model.rotate.Z + 90
                else:
                    new_rotation = model.rotate.Z - 90

                new_model = Model(path   = new_path,
                                  pos    = Coordinate(X =  position.X,                                       # + model.pos.Y * flip.X),
                                                      Y = (position.Y * flipped(aux_data.board_flip)) * -1,  # - model.pos.X * flip.Y),
                                                      Z =  model.pos.Z),
                                  scale  = model.scale,
                                  rotate = Coordinate(X = model.rotate.X,
                                                      Y = model.rotate.Y,
                                                      Z = new_rotation))  # footprint.position.angle)

            case _:  # angle is 0.0
                if aux_data.board_flip:
                    new_rotation = model.rotate.Z + 180
                else:
                    new_rotation = model.rotate.Z + 180

                new_model = Model(path   = new_path,
                                  pos    = Coordinate(X =  position.X,                                       # + model.pos.Y * flip.X),
                                                      Y = (position.Y * flipped(aux_data.board_flip)) * -1,  # - model.pos.X * flip.Y),
                                                      Z =  model.pos.Z),
                                  scale  = model.scale,
                                  rotate = Coordinate(X = model.rotate.X,
                                                      Y = model.rotate.Y,
                                                      Z = new_rotation))  # footprint.position.angle)

        modified_models.append(new_model)

    return modified_models
