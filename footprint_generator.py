#  ===================================================================
#  Source File Name : footprint_generator.py
#  Purpose          : Does the hard work to generate the footprint (from a board)
#  Author           : Alan Milne
#  #
#  This is copyright (C) 2022 to Alan Milne
#  ===================================================================

# import math
import os
import numpy
# import datetime

# from kiutils.board import *
from kiutils.libraries import *
from kiutils.symbol import SymbolLib

# from debug_print import *
from user_display_libtable import *
# from user_display_footprint import *
# from Supplemental_Classes import *
from Data_Mover import *


# ==================================================================================================================
def init_footprint(name: str):
    footprint             = Footprint()

    # There actually No point in setting LibraryLink as it's only appropriate in a board file!
    footprint.LibraryLink = name

    # Update to reflect Base Information
    # current date and time
    mydate                = datetime.datetime.now()
    # footprint.version     = str(mydate.strftime("%Y")) + str(mydate.strftime("%m")) + str(mydate.strftime("%d")) # Uncomment if want to use current date!
    # footprint.generator   = "MyGen" # Uncomment if you want to use an alternate generator!

    footprint.version     = "20211014"  # V6 Release date
    footprint.generator   = "pcbnew"
    footprint.description = name + ", generated by 'MyGen' on " + str(mydate.strftime("%d")) + "/" + str(mydate.strftime("%m")) + "/" + str(mydate.strftime("%Y"))

    return footprint


# ==================================================================================================================
def on_outline(item, outline_data):
    status = False

    if isinstance(item, FpLine) or isinstance(item, FpRect) or isinstance(item, FpArc) or \
            isinstance(item, GrLine) or isinstance(item, GrRect) or isinstance(item, GrArc):
        start_x = round(item.start.X, 6)
        start_y = round(item.start.Y, 6)
        end_x   = round(item.end.X, 6)
        end_y   = round(item.end.Y, 6)

        if (start_x == outline_data.top_right.X)   or (start_y == outline_data.top_right.Y) \
                or (end_x   == outline_data.top_right.X)   or (end_y   == outline_data.top_right.Y) \
                or (start_x == outline_data.bottom_left.X) or (start_y == outline_data.bottom_left.Y) \
                or (end_x   == outline_data.bottom_left.X) or (end_y   == outline_data.bottom_left.Y):
            status = True

    elif isinstance(item, FpCircle) or isinstance(item, GrCircle):
        delta_x = item.center.X - item.end.X
        delta_y = item.center.Y - item.end.Y

        radius = math.sqrt((delta_x * delta_x) + (delta_y * delta_y))

        right_edge  = round(item.center.X + radius, 6)
        left_edge   = round(item.center.X - radius, 6)
        top_edge    = round(item.center.Y + radius, 6)
        bottom_edge = round(item.center.Y - radius, 6)

        if (right_edge == outline_data.top_right.X)   or (left_edge == outline_data.top_right.X) \
                or (top_edge   == outline_data.top_right.Y)   or (bottom_edge == outline_data.top_right.Y) \
                or (right_edge == outline_data.bottom_left.X) or (left_edge   == outline_data.bottom_left.X) \
                or (top_edge   == outline_data.bottom_left.Y) or (bottom_edge == outline_data.bottom_left.Y):
            status = True

    elif isinstance(item, FpPoly) or isinstance(item, FpCurve) or isinstance(item, GrPoly) or isinstance(item, GrCurve):
        loop = 0
        start_x: float = 0.0
        start_y: float = 0.0
        end_x:   float = 0.0
        end_y:   float = 0.0

        for coordinate in item.coordinates:
            if loop == 0:
                start_x = coordinate.X
                start_y = coordinate.Y
            else:
                end_x = coordinate.X
                end_y = coordinate.Y

            loop = loop + 1

        if (start_x == outline_data.top_right.X)           or (start_y == outline_data.top_right.Y) \
                or (end_x   == outline_data.top_right.X)   or (end_y   == outline_data.top_right.Y) \
                or (start_x == outline_data.bottom_left.X) or (start_y == outline_data.bottom_left.Y) \
                or (end_y   == outline_data.bottom_left.X) or (end_y   == outline_data.bottom_left.Y):
            status = True

    return status


# ==================================================================================================================
def grow_distance(item):
    if isinstance(item, FpLine):
        grow = 1
    elif isinstance(item, FpArc):
        grow = 0
    else:  # FPCurve
        grow = 0

    return grow


# ==================================================================================================================
def normalisevec(x, y):
    distance = numpy.sqrt((x * x) + (y * y))

    if distance == 0:
        print(str(x) + " " + str(y))
        newx = 0
        newy = 0

    else:
        newx = x / distance
        newy = y / distance

    return newx, newy


# ==================================================================================================================
def make_offset_poly(oldx, oldy, offset, outer_ccw = 1):
    newx = []
    newy = []

    num_points = len(oldx)

    for curr in range(num_points):
        prevpt = (curr + num_points - 1) % num_points
        nextpt = (curr + 1) % num_points

        vnx =  oldx[nextpt] - oldx[curr]
        vny =  oldy[nextpt] - oldy[curr]
        vnnx, vnny = normalisevec(vnx, vny)
        nnnx = vnny
        nnny = -vnnx

        vpx =  oldx[curr] - oldx[prevpt]
        vpy =  oldy[curr] - oldy[prevpt]
        vpnx, vpny = normalisevec(vpx, vpy)
        npnx = vpny * outer_ccw
        npny = -vpnx * outer_ccw

        bisx = (nnnx + npnx) * outer_ccw
        bisy = (nnny + npny) * outer_ccw

        bisnx, bisny = normalisevec(bisx, bisy)
        bislen = offset / numpy.sqrt((1 + nnnx * npnx + nnny * npny) / 2)

        newx.append(oldx[curr] + bislen * bisnx)
        newy.append(oldy[curr] + bislen * bisny)

    return newx, newy


# ==================================================================================================================
def process_lines(loop, orig_last_item, last_item, current_item, next_item, orig_next_item, grow, layer):
    print("=== Lines " + str(loop) + " =================================================================")
    print("OLast   " + str(orig_last_item.start)    + " & " + str(orig_last_item.end))
    print("Last    " + str(last_item.start)         + " & " + str(last_item.end))
    print("Current " + str(current_item.start)      + " & " + str(current_item.end) + " Grow " + str(grow))
    print("Next    " + str(next_item.start)         + " & " + str(next_item.end))
    print("ONext   " + str(orig_next_item.start)    + " & " + str(orig_next_item.end))

    x = [0, current_item.start.X, current_item.end.X]
    y = [0, current_item.start.Y, current_item.end.Y]
    newx, newy = make_offset_poly(x, y, grow)

    print("Misc" + str(newx) + str(newy))

    # we need to grow line length if they are connect to another line - otherwise just connect to the arcs (and curves)
    if isinstance(current_item, FpLine):
        # need to determine new line (and then worry about the end effect

        new_start = Position()
        new_end = Position()

        if connecteditem(current_item.start, orig_last_item):  # Need to process that corner
            if isinstance(last_item, FpLine):
                # Todo:
                print("Line to Line - Start")
                new_start = current_item.start
                new_end   = current_item.end

            elif isinstance(last_item, FpArc):
                # apm print("Line to Arc - Start")
                if points_joined(current_item.start, orig_last_item.start):
                    new_start = last_item.start

                else:
                    new_start = last_item.end

                if points_joined(current_item.end, orig_next_item.start):
                    new_end = next_item.start
                else:
                    new_end = next_item.end

            elif isinstance(last_item, FpCurve):
                # apm print("Line to Curve - Start")
                # Todo: Not sure what to do here!
                new_start = current_item.start
                new_end   = current_item.end

        else:  # connect to te orig_next_item
            if isinstance(next_item, FpLine):
                # Todo:
                print("Line to Line - End")
                new_start = current_item.start
                new_end   = current_item.end

            elif isinstance(next_item, FpArc):
                # apm print("Line to Arc - End")
                if points_joined(current_item.start, orig_next_item.start):
                    new_start = next_item.start

                else:  # connected to end
                    new_start = next_item.end

                if points_joined(current_item.end, orig_last_item.start):
                    new_end = last_item.start

                else:
                    new_end = last_item.end

            elif isinstance(next_item, FpCurve):
                # Todo: Not sure what to do here!
                # apm print("Line to Curve - End")
                new_start = current_item.start
                new_end   = current_item.end

        new_item = FpLine(start  = new_start,
                          end    = new_end,
                          layer  = layer,
                          width  = 0.12,
                          stroke = None,
                          locked = False,
                          tstamp = current_item.tstamp)

    elif isinstance(current_item, FpArc):
        new_item = FpArc(start  = current_item.start,
                         mid    = current_item.mid,
                         end    = current_item.end,
                         layer  = layer,
                         width  = 0.12,
                         stroke = None,
                         locked = False,
                         tstamp = current_item.tstamp)

    else:
        # Don't know what to do here for now
        new_item = FpCurve(coordinates = current_item.coordinates,
                           layer       = layer,
                           width       = 0.12,
                           stroke      = None,
                           locked      = False,
                           tstamp      = current_item.tstamp)

    return new_item


# ==================================================================================================================
def process_curves(last_item, current_item, next_item, grow, layer):
    # we need to grow line length if they are connect to another line - otherwise just move it
    if isinstance(current_item, FpLine):
        # just re-draw the line for now will gix it presently
        new_item = FpLine(start  = current_item.start,
                          end    = current_item.end,
                          layer  = layer,
                          width  = 0.12,
                          stroke = None,
                          locked = False,
                          tstamp = current_item.tstamp)

    elif isinstance(current_item, FpArc):
        # apm print("=== Arcs ===================================================================")
        # apm print("Last    " + str(last_item.start) + " & " + str(last_item.end))
        # apm print("Current " + str(current_item.start) + " & " + str(current_item.end) + " Grow " + str(grow))
        # apm print("Next    " + str(next_item.start) + " & " + str(next_item.end))

        # center does not move but start/end points do
        circle = calc_circle(current_item.start, current_item.mid, current_item.end)

        startdist  = get_distance(current_item.start.X, current_item.start.Y)
        middist    = get_distance(current_item.mid.X,   current_item.mid.Y)
        enddist    = get_distance(current_item.end.X,   current_item.end.Y)
        centerdist = get_distance(circle.center.X, circle.center.Y)

        # apm print("Circle Info " + str(startdist) + " " + str(middist) + " " + str(enddist) + " " + str(centerdist))

        # When we calculate the angles, I'm not going to mess around with complex angles to rounding to 0.
        # This will introduce a small error but that's okay.
        if (startdist > centerdist) and (middist > centerdist) and (enddist > centerdist):
            start_angle  = non_kicad_angle(get_angle(current_item.start.X - circle.center.X, current_item.start.Y - circle.center.Y))
            middle_angle = non_kicad_angle(get_angle(current_item.mid.X - circle.center.X,   current_item.mid.Y - circle.center.Y))
            end_angle    = non_kicad_angle(get_angle(current_item.end.X - circle.center.X,   current_item.end.Y - circle.center.Y))

            new_radius = circle.radius + grow
            # apm print("Circle " + str(circle) + " " + str(new_radius))

            # apm print("Outer Angles " + str(start_angle) + " " + str(middle_angle) + " " + str(end_angle))

            newx = get_x(360, start_angle, new_radius)
            newy = get_y(360, start_angle, new_radius)

            # apm print("Start  " + str(newx) + " " + str(newy))

            new_start  = Position(X        = circle.center.X + newx,
                                  Y        = circle.center.Y + newy,
                                  angle    = current_item.start.angle,
                                  unlocked = current_item.start.unlocked)

            newx = get_x(360, middle_angle, new_radius)
            newy = get_y(360, middle_angle, new_radius)

            # apm print("Middle " + str(newx) + " " + str(newy))

            new_middle = Position(X        = circle.center.X + newx,
                                  Y        = circle.center.Y + newy,
                                  angle    = current_item.start.angle,
                                  unlocked = current_item.start.unlocked)

            newx = get_x(360, end_angle, new_radius)
            newy = get_y(360, end_angle, new_radius)

            # apm print("End    " + str(newx) + " " + str(newy))

            new_end    = Position(X        = circle.center.X + newx,
                                  Y        = circle.center.Y + newy,
                                  angle    = current_item.start.angle,
                                  unlocked = current_item.start.unlocked)

            new_item = FpArc(start  = new_start,
                             mid    = new_middle,
                             end    = new_end,
                             layer  = layer,
                             width  = 0.12,
                             stroke = None,
                             locked = False,
                             tstamp = current_item.tstamp)
        else:
            # This is an inner arc, so we shrink rather than grow, and We only need to shrink if there is enough radius to do so.
            if circle.radius > grow:
                start_angle  = non_kicad_angle(get_angle(current_item.start.X - circle.center.X, current_item.start.Y - circle.center.Y))
                middle_angle = non_kicad_angle(get_angle(current_item.mid.X - circle.center.X, current_item.mid.Y - circle.center.Y))
                end_angle    = non_kicad_angle(get_angle(current_item.end.X - circle.center.X, current_item.end.Y - circle.center.Y))

                new_radius = circle.radius - grow
                # apm print("Circle " + str(circle) + " " + str(new_radius))

                # apm print("Inner Angles " + str(start_angle) + " " + str(middle_angle) + " " + str(end_angle))

                new_start  = Position(X        = circle.center.X - get_x(360, start_angle, new_radius),
                                      Y        = circle.center.Y - get_y(360, start_angle, new_radius),
                                      angle    = current_item.start.angle,
                                      unlocked = current_item.start.unlocked)

                new_middle = Position(X        = circle.center.X - get_x(360, middle_angle, new_radius),
                                      Y        = circle.center.Y - get_y(360, middle_angle, new_radius),
                                      angle    = current_item.start.angle,
                                      unlocked = current_item.start.unlocked)

                new_end    = Position(X        = circle.center.X - get_x(360, end_angle, new_radius),
                                      Y        = circle.center.Y - get_y(360, end_angle, new_radius),
                                      angle    = current_item.start.angle,
                                      unlocked = current_item.start.unlocked)

                new_item = FpArc(start  = new_start,
                                 mid    = new_middle,
                                 end    = new_end,
                                 layer  = layer,
                                 width  = 0.12,
                                 stroke = None,
                                 locked = False,
                                 tstamp = current_item.tstamp)
            else:
                start_angle  = non_kicad_angle(get_angle(current_item.start.X - circle.center.X, current_item.start.Y - circle.center.Y))
                middle_angle = non_kicad_angle(get_angle(current_item.mid.X - circle.center.X, current_item.mid.Y - circle.center.Y))
                end_angle    = non_kicad_angle(get_angle(current_item.end.X - circle.center.X, current_item.end.Y - circle.center.Y))

                new_radius = 0
                # apm print("Circle " + str(circle) + " " + str(new_radius))

                # apm print("Inner Angles " + str(start_angle) + " " + str(middle_angle) + " " + str(end_angle))

                new_start  = Position(X        = circle.center.X,
                                      Y        = circle.center.Y,
                                      angle    = current_item.start.angle,
                                      unlocked = current_item.start.unlocked)

                new_middle = Position(X        = circle.center.X,
                                      Y        = circle.center.Y,
                                      angle    = current_item.start.angle,
                                      unlocked = current_item.start.unlocked)

                new_end    = Position(X        = circle.center.X,
                                      Y        = circle.center.Y,
                                      angle    = current_item.start.angle,
                                      unlocked = current_item.start.unlocked)

                new_item = FpArc(start  = new_start,
                                 mid    = new_middle,
                                 end    = new_end,
                                 layer  = layer,
                                 width  = 0.12,
                                 stroke = None,
                                 locked = False,
                                 tstamp = current_item.tstamp)

    else:
        # apm print("=== Curves =================================================================")
        # apm print("Last    " + str(last_item.start) + " & " + str(last_item.end))
        # apm print("Current " + str(current_item.start) + " & " + str(current_item.end) + " Grow " + str(grow))
        # apm print("Next    " + str(next_item.start) + " & " + str(next_item.end))

        # Don't know what to do here for now
        new_item = FpCurve(coordinates = current_item.coordinates,
                           layer       = layer,
                           width       = 0.12,
                           stroke      = None,
                           locked      = False,
                           tstamp      = current_item.tstamp)

    return new_item


# ==================================================================================================================
def printer(loop, lst, cur, nxt):
    match loop:
        case 14:
            data = "TopR "
        case 1:
            data = "InR  "
        case 2:
            data = "IArc "
        case 3:
            data = "InB  "
        case 4:
            data = "IArc "
        case 5:
            data = "InL  "
        case 6:
            data = "TopL "
        case 7:
            data = "OArc "
        case 8:
            data = "Left "
        case 9:
            data = "OArc "
        case 10:
            data = "Bot  "
        case 11:
            data = "OArcO"
        case 12:
            data = "Right"
        case 13:
            data = "OArc "
        case _:
            data = "---"

    print("============================================================================")
    print("Loop = " + str(loop) + " " + data)
    # apm print("Loop = " + str(loop) + " " + data + " (" + str(type(lst)) + "/" + str(type(cur)) + "/" + str(type(nxt)) + ")")
    print("       " + str(round(lst.start.X, 3)) + "," + str(round(lst.start.Y, 3)) + " " +
          str(round(lst.end.X, 3))   + "," + str(round(lst.end.Y, 3))   + " | " +
          str(round(cur.start.X, 3)) + "," + str(round(cur.start.Y, 3)) + " " +
          str(round(cur.end.X, 3))   + "," + str(round(cur.end.Y, 3))   + " | " +
          str(round(nxt.start.X, 3)) + "," + str(round(nxt.start.Y, 3)) + " " +
          str(round(nxt.end.X, 3))   + "," + str(round(nxt.end.Y, 3)))


# ==================================================================================================================
def print_items(items):
    print("=== Outline data ====================================================")

    for loop, item in enumerate(items):
        print("Item " + str(loop + 1) + " " + str(item.start) + " " + str(item.end) + " " + str(type(item)))

    print("=== Outline data ====================================================")


# ==================================================================================================================
# Get the start and end points for the graphic item
def grow_items(items, grow, layer):
    new_items = []

    origx = []
    origy = []

    startx = Position()
    starty = Position()

    for loop, item in enumerate(items):
        if loop == 0:
            if connecteditem(item.start, items[1]):
                if points_joined(item.start, items[1].start):
                    # Need to remember the start so that we can close the shape
                    startx = item.end.X
                    starty = item.end.Y

                    # Make start the first point
                    origx.append(startx)
                    origy.append(starty)

                    # And add the connecting point
                    origx.append(item.items[1].start.X)
                    origy.append(item.items[1].start.Y)

                else:  # connected to items[loop].end:
                    # Need to remember the start so that we can close the shape
                    startx = item.start.X
                    starty = item.start.Y

                    # Make start the first point
                    origx.append(startx)
                    origy.append(starty)

                    # And add the connecting point
                    origx.append(item.items[1].end.X)
                    origy.append(item.items[1].end.Y)

            else:  # connected to items[loop].end:
                if points_joined(item.end, items[loop + 1].start):
                    # Need to remember the start so that we can close the shape
                    startx = item.start.X
                    starty = item.start.Y

                    # Make start the first point
                    origx.append(startx)
                    origy.append(starty)

                    # And add the connecting point
                    origx.append(items[1].start.X)
                    origy.append(items[1].start.Y)

                else:  # connected to items[loop].end:
                    # Need to remember the start so that we can close the shape
                    startx = item.end.X
                    starty = item.end.Y

                    # Make start the first point
                    origx.append(startx)
                    origy.append(starty)

                    # And add the connecting point
                    origx.append(items[1].end.X)
                    origy.append(items[1].end.Y)

        elif loop == (len(items) - 1):  # last point
            # And add the starting point
            # origx.append(startx)
            # origy.append(starty)
            # path.append("LINE 14, Original Start")
            print("-")

        else:  # intermediate points
            if connecteditem(item.start, items[loop + 1]):
                if points_joined(item.start, items[loop + 1].start):
                    # Make start the first point
                    origx.append(items[loop + 1].start.X)
                    origy.append(items[loop + 1].start.Y)

                else:  # connected to items[loop].end:
                    # Make end the first point
                    origx.append(items[loop + 1].end.X)
                    origy.append(items[loop + 1].end.Y)

            else:  # connected to items[loop].end:
                if points_joined(item.end, items[loop + 1].start):
                    # Make start the first point
                    origx.append(items[loop + 1].start.X)
                    origy.append(items[loop + 1].start.Y)

                else:  # connected to items[loop].end:
                    # Make start the first point
                    origx.append(items[loop + 1].end.X)
                    origy.append(items[loop + 1].end.Y)

    # determine rotation
    if get_rotation(get_angle(origx[0], origy[0]), get_angle(origx[1], origy[1]), get_angle(origx[2], origy[2])):
        # clockwise
        direction = -1
    else:
        # counter-clockwise
        direction = 1

    newx, newy = make_offset_poly(origx, origy, grow * direction)
    print("Misc" + str(newx) + str(newy))

    for loop, item in enumerate(items):
        if loop == len(items) - 1:
            print(str(round(newx[loop], 6)) + "," + str(round(newy[loop], 6)) + " " + str(round(newx[0], 6)) + str(round(newy[0], 6)))

            new_start = Position(X        = round(newx[loop], 6),
                                 Y        = round(newy[loop], 6),
                                 angle    = None,
                                 unlocked = False)

            new_end =   Position(X        = round(newx[0], 6),
                                 Y        = round(newy[0], 6),
                                 angle    = None,
                                 unlocked = False)

            new_items.append(FpLine(start  = new_start,
                                    end    = new_end,
                                    layer  = layer,
                                    width  = 0.12,
                                    stroke = None,
                                    locked = False,
                                    tstamp = items[loop].tstamp))

        else:
            print(str(round(newx[loop], 6)) + "," + str(round(newy[loop], 6)) + " " + str(round(newx[loop + 1], 6)) + str(round(newy[loop + 1], 6)))

            new_start = Position(X        = round(newx[loop], 6),
                                 Y        = round(newy[loop], 6),
                                 angle    = None,
                                 unlocked = False)

            new_end =   Position(X        = round(newx[loop + 1], 6),
                                 Y        = round(newy[loop + 1], 6),
                                 angle    = None,
                                 unlocked = False)

            new_items.append(FpLine(start  = new_start,
                                    end    = new_end,
                                    layer  = layer,
                                    width  = 0.12,
                                    stroke = None,
                                    locked = False,
                                    tstamp = items[loop].tstamp))

    return new_items


# ==================================================================================================================
# Get the start and end points for the graphic item
def grow_items2(items, grow, layer):
    pass1_items = []
    pass2_items = []

    current_item = None

    middle = Position()

    # apm print_items(items)

    # do a pass to fine arcs (and curves) grow them, this is important so that we can make lines join up with the arcs (and curves).
    for loop, item in enumerate(items):
        if loop == 0:
            last_item      = items[len(items) - 1]
            current_item   = item
            next_item      = items[loop + 1]

        elif loop == len(items) - 1:
            last_item    = current_item
            current_item = item
            next_item    = items[0]

        else:
            last_item    = current_item
            current_item = item
            next_item    = items[loop + 1]

        printer(loop + 1, last_item, current_item, next_item)

        pass1_items.append(process_curves(last_item, current_item, next_item, grow, "Margin"))

    # apm print_items(pass1_items)

    # do a 2nd pass to do lines.
    for loop, item in enumerate(pass1_items):
        if loop == 0:
            orig_last_item = items[len(items) - 1]
            last_item      = pass1_items[len(pass1_items) - 1]
            current_item   = item
            next_item      = pass1_items[loop + 1]
            orig_next_item = items[loop + 1]

        elif loop == len(pass1_items) - 1:
            orig_last_item = items[loop - 1]
            last_item      = current_item
            current_item   = item
            next_item      = pass1_items[0]
            orig_next_item = items[0]

        else:
            orig_last_item = items[loop - 1]
            last_item      = current_item
            current_item   = item
            next_item      = pass1_items[loop + 1]
            orig_next_item = items[loop + 1]

        printer(loop + 1, last_item, current_item, next_item)

        pass2_items.append(process_lines(loop + 1, orig_last_item, last_item, current_item, next_item, orig_next_item, grow, layer))

        if isinstance(item, FpArc):
            middle = item.mid

        elif isinstance(item, FpLine):
            middle = Position(X        = item.start.X - ((item.start.X - item.end.X) / 2),
                              Y        = item.start.Y - ((item.start.Y - item.end.Y) / 2),
                              angle    = None,
                              unlocked = False)

        pass2_items.append(kicad_debug(str(loop + 1), middle, "User.7"))

        if isinstance(current_item, FpLine):
            pass2_items.append(kicad_debug("S", current_item.start, "User.9"))
            pass2_items.append(kicad_debug("E", current_item.end,   "User.9"))

        elif isinstance(current_item, FpArc):
            pass2_items.append(kicad_debug("S", current_item.start, "User.8"))
            pass2_items.append(kicad_debug("E", current_item.end,   "User.8"))

    # apm print_items(pass2_items)

    return pass2_items


# ==================================================================================================================
# Get the start and end points for the graphic item
def get_ends(item):
    ends: List() = []

    if isinstance(item, FpLine) or isinstance(item, FpArc) or isinstance(item, GrLine) or isinstance(item, GrArc):
        ends.append(item.start)
        ends.append(item.end)

    elif isinstance(item, FpCurve) or isinstance(item, GrCurve):
        ends.append(item.coordinates[0])
        ends.append(item.coordinates[len(item.coordinates)])

    return ends


# ==================================================================================================================
def connecteditem(point, item):
    status = False

    # Don't need to worry abot text, textbox, polygon or circle - the later two causes they are closed shapes.

    if isinstance(item, FpLine) or isinstance(item, FpArc):
        if points_joined(point, item.start) or points_joined(point, item.end):
            status = True

    elif isinstance(item, FpCurve):
        if points_joined(point, item.coordinates[0]) or points_joined(point, item.coordinates[len(item.coordinates) - 1]):
            status = True

    return status


# ==================================================================================================================
def connected2outline(item, outline_points):
    status = False

    # Don't need to worry abot text, textbox, polygon or circle - the later two causes they are closed shapes.

    if isinstance(item, FpLine) or isinstance(item, FpArc):
        for point in outline_points:
            if item.start.X == point.X or item.start.Y == point.Y or item.end.X == point.X or item.end.Y == point.Y:
                status = True

    elif isinstance(item, FpCurve):
        for point in outline_points:
            if item.coordinates[0] == point.X or item.coordinates[0].Y == point.Y or item.coordinates[len(item.coordinates) - 1].X == point.X \
                    or item.coordinates[len(item.coordinates) - 1].Y == point.Y:
                status = True

    return status


# ==================================================================================================================
def points_joined(current_point, test_point):
    status = False

    if (test_point.X == current_point.X) and (test_point.Y == current_point.Y):
        status = True

    # apm print("====== " + str(status))

    # apm print(str(test_point.X) + "," + str(test_point.Y) + " " + str(current_point.X) + "," + str(current_point.Y))
    # apm print(str(round(test_point.X, 6)) + "," + str(round(test_point.Y, 6)) + " " + str(round(current_point.X, 6)) + "," + str(round(current_point.Y, 6)))
    return status


# ==================================================================================================================
def startpoint(item, start):
    startpos = Position()
    endpos   = Position()

    if isinstance(item, FpLine) or isinstance(item, FpArc):
        startpos = item.start
        endpos   = item.end

    elif isinstance(item, FpCurve):
        startpos = item.coordinates[0]
        endpos   = item.coordinates[len(item.coordinates) - 1]

    if start:
        return startpos
    else:
        return endpos


# ==================================================================================================================
# Trawls through all the graphic items that are on EdgeCut on the board and copy them to f.fab on footprint
def create_outline(gr_items, outline_data, flip):
    outline_items:           List() = []
    organised_outline_items: List() = []
    outline_points:          List() = []
    non_outline_items:       List() = []

    # outline = OutlineData(board_edge     = list(),
    #                       non_board_edge = list())
    outline = OutlineData()

    outline.board_edge     = []
    outline.non_board_edge = []

    poly_circle_outline = False

    # Trawl for items on the Edge.Cuts lay as they are what we want to use, if used, then convert to fp (from gr)
    # Also want to move to "F.Fab" and set width.
    for gitem in gr_items:
        # ignore if on text or textbox

        if isinstance(gitem, GrLine):
            if gitem.layer == "Edge.Cuts":
                new_start = Position(X        = pt_soff(gitem.start, outline_data.centroid).X,
                                     Y        = pt_soff(gitem.start, outline_data.centroid).Y * flipped(flip),
                                     angle    = gitem.start.angle,
                                     unlocked = gitem.start.unlocked)

                new_end   = Position(X        = pt_soff(gitem.end, outline_data.centroid).X,
                                     Y        = pt_soff(gitem.end, outline_data.centroid).Y * flipped(flip),
                                     angle    = gitem.end.angle,
                                     unlocked = gitem.end.unlocked)

                fitem_fab = FpLine(start  = new_start,
                                   end    = new_end,
                                   layer  = "F.Fab",
                                   width  = 0.1,
                                   stroke = None,
                                   locked = False,
                                   tstamp = gitem.tstamp)

                if on_outline(fitem_fab, outline_data):
                    outline_items.append(fitem_fab)
                    outline_points.extend(get_ends(fitem_fab))

                else:
                    non_outline_items.append(fitem_fab)

        elif isinstance(gitem, GrRect):
            if gitem.layer == "Edge.Cuts":
                new_start = Position(X        = pt_soff(gitem.start, outline_data.centroid).X,
                                     Y        = pt_soff(gitem.start, outline_data.centroid).Y * flipped(flip),
                                     angle    = gitem.start.angle,
                                     unlocked = gitem.start.unlocked)

                new_end   = Position(X        = pt_soff(gitem.end, outline_data.centroid).X,
                                     Y        = pt_soff(gitem.end, outline_data.centroid).Y * flipped(flip),
                                     angle    = gitem.end.angle,
                                     unlocked = gitem.end.unlocked)

                fitem_fab = FpRect(start  = new_start,
                                   end    = new_end,
                                   layer  = "F.Fab",
                                   width  = 0.1,
                                   stroke = None,
                                   fill   = gitem.fill,
                                   locked = False,
                                   tstamp = gitem.tstamp)

                if on_outline(fitem_fab, outline_data):
                    # Rectangular outline so nothing else to do, but should move any spurious items to non-outline
                    for item in outline_items:
                        non_outline_items.append(item)

                    outline_items = list()
                    outline_items.append(fitem_fab)

                else:
                    non_outline_items.append(fitem_fab)

        elif isinstance(gitem, GrCircle):
            if gitem.layer == "Edge.Cuts":
                new_center = Position(X        = pt_soff(gitem.center, outline_data.centroid).X,
                                      Y        = pt_soff(gitem.center, outline_data.centroid).Y * flipped(flip),
                                      angle    = gitem.center.angle,
                                      unlocked = gitem.center.unlocked)

                new_end    = Position(X        =pt_soff(gitem.end, outline_data.centroid).X,
                                      Y        =pt_soff(gitem.end, outline_data.centroid).Y * flipped(flip),
                                      angle    =gitem.end.angle,
                                      unlocked =gitem.end.unlocked)

                fitem_fab  = FpCircle(center = new_center,
                                      end    = new_end,
                                      layer  = "F.Fab",
                                      width  = 0.1,
                                      stroke = None,
                                      fill   = gitem.fill,
                                      locked = False,
                                      tstamp = gitem.tstamp)

                if on_outline(fitem_fab, outline_data):
                    # Circular outline so nothing else to do, but should move any spurious items to non-outline
                    for item in outline_items:
                        non_outline_items.append(item)

                    outline_items = list()
                    outline_items.append(fitem_fab)

                    poly_circle_outline = True

                else:
                    non_outline_items.append(fitem_fab)

        elif isinstance(gitem, GrArc):
            if gitem.layer == "Edge.Cuts":
                # Need to swap start and end.
                if flip:  # flip
                    start = gitem.end
                    middle = gitem.mid
                    end = gitem.start

                else:    # no flip
                    start = gitem.start
                    middle = gitem.mid
                    end = gitem.end

                # Fab Layer
                new_start = Position(X        = pt_soff(start, outline_data.centroid).X,
                                     Y        = pt_soff(start, outline_data.centroid).Y * flipped(flip),
                                     angle    = start.angle,
                                     unlocked = start.unlocked)

                new_mid   = Position(X        = pt_soff(middle, outline_data.centroid).X,
                                     Y        = pt_soff(middle, outline_data.centroid).Y * flipped(flip),
                                     angle    = middle.angle,
                                     unlocked = middle.unlocked)

                new_end   = Position(X        = pt_soff(end, outline_data.centroid).X,
                                     Y        = pt_soff(end, outline_data.centroid).Y * flipped(flip),
                                     angle    = end.angle,
                                     unlocked = end.unlocked)

                fitem_fab = FpArc(start  = new_start,
                                  mid    = new_mid,
                                  end    = new_end,
                                  layer  = "F.Fab",
                                  width  = gitem.width,
                                  stroke = None,
                                  locked = False,
                                  tstamp = gitem.tstamp)

                if on_outline(fitem_fab, outline_data):
                    outline_items.append(fitem_fab)
                    outline_points.extend(get_ends(fitem_fab))

                else:
                    non_outline_items.append(fitem_fab)

        elif isinstance(gitem, GrPoly):
            if gitem.layer == "Edge.Cuts":
                new_coords = list()

                for coord in gitem.coordinates:
                    new_coords.append(Position(X        = pt_soff(coord, outline_data.centroid).X,
                                               Y        = pt_soff(coord, outline_data.centroid).Y * flipped(flip),
                                               angle    = coord.angle,
                                               unlocked = coord.unlocked))

                fitem_fab = FpPoly(coordinates = new_coords,
                                   layer       = "F.Fab",
                                   width       = 0.1,
                                   stroke      = None,
                                   fill        = gitem.fill,
                                   locked      = False,
                                   tstamp      = gitem.tstamp)

                if on_outline(fitem_fab, outline_data):
                    # Closed Polygon outline so nothing else to do, but should move any spurious items to non-outline
                    for item in outline_items:
                        non_outline_items.append(item)

                    outline_items = list()
                    outline_items.append(fitem_fab)

                    poly_circle_outline = True
                else:
                    non_outline_items.append(fitem_fab)

        elif isinstance(gitem, GrCurve):
            if gitem.layer == "Edge.Cuts":
                # Fab, Silkscreen and Courtyard Layers
                new_coords = list()

                for coord in gitem.coordinates:
                    new_coords.append(Position(X        = pt_soff(coord, outline_data.centroid).X,
                                               Y        = pt_soff(coord, outline_data.centroid).Y * flipped(flip),
                                               angle    = coord.angle,
                                               unlocked = coord.unlocked))

                fitem_fab = FpCurve(coordinates = new_coords,
                                    layer       = "F.Fab",
                                    width       = 0.1,
                                    stroke      = None,
                                    locked      = False,
                                    tstamp      = gitem.tstamp)

                if on_outline(fitem_fab, outline_data):
                    outline_items.append(fitem_fab)
                    outline_points.extend(get_ends(fitem_fab))

                else:
                    non_outline_items.append(fitem_fab)

    if not poly_circle_outline:
        # keep looking for items that are the outline.
        outline_finished = False

        # new look to see if there is anything inside the extents but connects to the outline
        while not outline_finished:
            outline_finished = True

            for item in non_outline_items:
                if connected2outline(item, outline_points):
                    outline_items.append(item)
                    non_outline_items.remove(item)

                    data = get_ends(item)
                    outline_points.extend(data)

                    outline_finished = False

    # Now we know all the outline items so organise them so that they are is sequence - where we start is irrelevant.
    # this is important so that we can grow the shape presently
    end   = startpoint(outline_items[0], False)

    organised_outline_items.append(outline_items[0])
    outline_items.remove(outline_items[0])

    while len(outline_items) > 0:
        for item in outline_items:
            test_start = startpoint(item, True)
            test_end   = startpoint(item, False)

            if points_joined(end, test_start):
                # found a matching point
                end = test_end
                organised_outline_items.append(item)
                outline_items.remove(item)

            elif points_joined(end, test_end):
                # found a matching point
                end = test_start
                organised_outline_items.append(item)
                outline_items.remove(item)

    outline.board_edge     = organised_outline_items
    outline.non_board_edge = non_outline_items

    return outline


# ==================================================================================================================
def select_connectors(footprints, flip):
    menu_data = list()

    for footprint in footprints:

        component_id = None
        component_type = None

        for fitem in footprint.graphicItems:
            if isinstance(fitem, FpText):
                if fitem.type == 'reference':
                    component_id = fitem.text

                elif fitem.type == 'value':
                    component_type = fitem.text

        if (component_id is not None) and (component_type is not None):  # and (footprint.layer == component_layer):
            if footprint.attributes.type is None:
                display_text = "[" + footprint.layer + "] Not Defined    : " + component_id + "/" + component_type
            else:
                if footprint.attributes.type == "smd":
                    display_text = "[" + footprint.layer + "] SMD                 : " + component_id + "/" + component_type
                else:
                    display_text = "[" + footprint.layer + "] Through Hole : " + component_id + "/" + component_type

            menu_data.append(display_text)

    if len(menu_data) > 1:
        # it is helpful to (pre)select the components on the correct side of the board
        preselect = list()
        select_pos = 0

        # sort data to make it easier to select components
        menu_data = sorted(menu_data)

        # Use flip to decide which components are likely to be selected
        for component in menu_data:
            if flip:  # flip
                if component[0:3] == "[F.":
                    preselect.append(select_pos)
            else:  # No flip
                if component[0:3] == "[B.":
                    preselect.append(select_pos)

            select_pos += 1

        # now select the components we want to use
        field_values = multchoicebox(msg="Select the component(s) that you want to appear as pads on the footprint.",
                                     title="Component Selection",
                                     choices=menu_data,
                                     preselect=preselect)
    else:
        field_values = menu_data

    return field_values


# ==================================================================================================================
# Need to check that output directories exist and if not create them.
def manage_layout_lib_dir(odir):
    # We need to create "MyGen.Pretty" so that we can save the footprint and then update the library,
    # but only if it does not exist. Also need to check for a "Shapes_3D" directory and create if necessary.
    # We also need to figure out what 3D files we need copy them if necessary to the "Shapes_3D" file.
    library_exist = os.path.exists(odir + "\\" + "MyGen.Pretty")

    if library_exist:
        shapes_exist = os.path.exists(odir + "\\" + "MyGen.Pretty" + "\\" + "Shapes_3D")

        if not shapes_exist:
            os.makedirs(odir + "\\" + "MyGen.Pretty" + "\\" + "Shapes_3D")

    else:
        os.makedirs(odir + "\\" + "MyGen.Pretty")
        os.makedirs(odir + "\\" + "MyGen.Pretty" + "\\" + "Shapes_3D")

    # now read the library to see if it points to the library "MyGen.Pretty", if not add it
    if path.exists(odir + "\\" + "fp-lib-table"):
        pcb_lib_table = LibTable().from_file(odir + "\\" + "fp-lib-table")

        lib_not_found = True

        for loop, lib in enumerate(pcb_lib_table.libs):
            if lib.name == "MyGen":
                # There is an issues here - if a project is copied, then "MyGen" will be found but will be invalid so need to address.
                if lib.uri == odir + "MyGen.Pretty":
                    # Found it
                    lib_not_found = False
                else:  # found something, but it's wrong so remove it - we'll add it later as if it was never existed.
                    pcb_lib_table.libs.remove(lib)

    else:
        # Can't file the "fp-lib-table" so create an empty file!
        pcb_lib_table = LibTable(type="fp_lib_table")
        lib_not_found = True

    # "MyGen.Pretty" Not found so need to add it
    if lib_not_found:
        # add new Library
        new_lib = Library()

        new_lib.name        = "MyGen"
        new_lib.type        = "KiCad"
        new_lib.uri         = odir + "MyGen.Pretty"
        new_lib.options     = ""
        new_lib.description = ""

        pcb_lib_table.libs.append(new_lib)

        pcb_lib_table.to_file(odir + "\\" + "fp-lib-table")


# ==================================================================================================================
# Need to calculate certain values about the selected footprint so that we can add pads, models, etc. correctly.
def add_component_data(footprints, menu_data, centroid_offset, board_flip):
    component_data = Component()
    aux_data       = AuxData()

    aux_data.centroid_offset = centroid_offset
    aux_data.board_flip = board_flip

    for component in menu_data:
        # Need to recover component mount technology, ID and Type
        # component_mount = component[0:component.find(" : ")]

        aux_data.id = component[component.find(" : ") + 3:component.find("/")]
        aux_data.type = component[component.find("/") + 1:len(component)]

        for footprint in footprints:
            id_match = False
            component_match = False
            aux_data.longaxis_x = False
            aux_data.center_origin = False

            for fitem in footprint.graphicItems:
                if isinstance(fitem, FpText):
                    # If text property match the ID then this might be the footprint
                    if fitem.type == 'reference':
                        if fitem.text == aux_data.id:
                            id_match = True

                    # If text property match the TYPE then this might be the footprint
                    elif fitem.type == 'value':
                        if fitem.text == aux_data.type:
                            # if we've also found the ID all is good
                            if id_match:
                                component_match = True
                                break

            # found a selected component, so copy data
            if component_match:

                # need to determine where the pads are to calculate the swap direction and (maybe) the center
                top_right = Coordinate2D()
                bottom_left = Coordinate2D()

                # cycle round the pads to find the center - TODO: this may be better done on via the courtyard layer?
                for pad in footprint.pads:
                    if pad.position.X > top_right.X:
                        top_right.X = pad.position.X

                    if pad.position.Y > top_right.Y:
                        top_right.Y = pad.position.Y

                    if pad.position.X < bottom_left.X:
                        bottom_left.X = pad.position.X

                    if pad.position.Y < bottom_left.Y:
                        bottom_left.Y = pad.position.Y

                # Use LibraryLink to figure out some stuff
                if footprint.attributes.type == "smd":
                    aux_data.center_origin = True

                    # SMD then origin is known!
                    aux_data.center.X = 0.0
                    aux_data.center.Y = 0.0

                    if (top_right.X - bottom_left.X) > (top_right.Y - bottom_left.Y):
                        aux_data.longaxis_x = True

                    else:
                        aux_data.longaxis_x = False

                elif footprint.attributes.type == "through_hole":
                    aux_data.center_origin = False

                    aux_data.center.X = ((top_right.X - bottom_left.X) / 2) + bottom_left.X
                    aux_data.center.Y = ((top_right.Y - bottom_left.Y) / 2) + bottom_left.Y

                    if (top_right.X - bottom_left.X) > (top_right.Y - bottom_left.Y):
                        aux_data.longaxis_x = True

                    else:
                        aux_data.longaxis_x = False

                else:  # anything else (none or other)/
                    aux_data.center.X = ((top_right.X - bottom_left.X) / 2) + bottom_left.X
                    aux_data.center.Y = ((top_right.Y - bottom_left.Y) / 2) + bottom_left.Y

                    if ynbox("Do you want to flip " + aux_data.id + "?", "Flip selection", ["X-Axis", "Y-Axis"]) == 1:
                        aux_data.longaxis_x = True
                    else:
                        aux_data.longaxis_x = False

                # now add the footprints for the components select
                component_data.components.append(aux_data.id)
                component_data.pads.extend(add_footprint_pads(footprint, aux_data))
                component_data.graphicitems.extend(add_footprint_silkscreen(footprint, aux_data))
                component_data.models.extend(add_footprint_models(footprint, aux_data))

    return component_data


# ==================================================================================================================
# now add the footprint data for the components select
def add_footprint_pads(footprint, aux_data):
    modified_pads = list()

    for pad in footprint.pads:
        # make new pin based on the ID & the original pad number
        new_number = aux_data.id + "-" + pad.number

        if aux_data.board_flip:  # Flip so leave as is
            new_layers = pad.layers
        else:  # No flip so swap layers
            new_layers = []

            for layer in pad.layers:
                if layer.find("F.") == 0:
                    new_layers.append(layer.replace("F.", "B."))
                elif layer.find("B.") == 0:
                    new_layers.append(layer.replace("B.", "F."))
                else:
                    new_layers.append(layer)

        modified_pads.append(Pad(number                = new_number,
                                 type                  = pad.type,
                                 shape                 = pad.shape,
                                 position              = new_coordinate_position(footprint.position, pad.position, aux_data),
                                 locked                = True,
                                 size                  = pad.size,
                                 drill                 = pad.drill,
                                 layers                = new_layers,
                                 property              = None,
                                 removeUnusedLayers    = pad.removeUnusedLayers,
                                 keepEndLayers         = pad.keepEndLayers,
                                 roundrectRatio        = pad.roundrectRatio,
                                 chamferRatio          = pad.chamferRatio,
                                 chamfer               = pad.chamfer,
                                 net                   = None,
                                 tstamp                = pad.tstamp,
                                 pinFunction           = pad.pinFunction,
                                 pinType               = pad.pinType,
                                 dieLength             = pad.dieLength,
                                 solderMaskMargin      = pad.solderMaskMargin,
                                 solderPasteMargin     = pad.solderPasteMargin,
                                 solderPasteMarginRatio= pad.solderPasteMarginRatio,
                                 clearance             = pad.clearance,
                                 zoneConnect           = None,
                                 thermalWidth          = None,
                                 thermalGap            = None,
                                 customPadOptions      = None,
                                 customPadPrimitives   = None))

    # =========================================================================================
    # Debug code - draws a pad at the center
    # modified_pads.append(Pad(number                 = "Center",
    #                          type                   = "smd",
    #                          shape                  = "circle",
    #                          position               = center_position,
    #                          locked                 = True,
    #                          size                   = pad.size,
    #                          drill                  = pad.drill,
    #                          layers                 = pad.layers,
    #                          property               = None,
    #                          removeUnusedLayers     = pad.removeUnusedLayers,
    #                          keepEndLayers          = pad.keepEndLayers,
    #                          roundrectRatio         = pad.roundrectRatio,
    #                          chamferRatio           = pad.chamferRatio,
    #                          chamfer                = pad.chamfer,
    #                          net                    = None,
    #                          tstamp                 = pad.tstamp,
    #                          pinFunction            = pad.pinFunction,
    #                          pinType                = pad.pinType,
    #                          dieLength              = pad.dieLength,
    #                          solderMaskMargin       = pad.solderMaskMargin,
    #                          solderPasteMargin      = pad.solderPasteMargin,
    #                          solderPasteMarginRatio = pad.solderPasteMarginRatio,
    #                          clearance              = pad.clearance,
    #                          zoneConnect            = None,
    #                          thermalWidth           = None,
    #                          thermalGap             = None,
    #                          customPadOptions       = None,
    #                          customPadPrimitives    = None))
    # =========================================================================================

    return modified_pads


# ==================================================================================================================
# now add the footprint data for the components select
def add_footprint_silkscreen(footprint, aux_data):
    modified_items = list()

    for gitem in footprint.graphicItems:
        # Don't need to worry about text and textbox
        if isinstance(gitem, FpLine):
            if (gitem.layer == "F.SilkS") or (gitem.layer == "B.SilkS"):
                if gitem.width < 0.1:
                    gitem.width = 0.1

                # Silkscreen Layer
                modified_items.append(FpLine(start  = new_coordinate_position(footprint.position, gitem.start, aux_data),
                                             end    = new_coordinate_position(footprint.position, gitem.end, aux_data),
                                             layer  = "F.SilkS",
                                             width  = gitem.width,
                                             stroke = None,
                                             locked = True,
                                             tstamp = gitem.tstamp))

        elif isinstance(gitem, FpRect):
            if (gitem.layer == "F.SilkS") or (gitem.layer == "B.SilkS"):
                if gitem.width < 0.1:
                    gitem.width = 0.1

                modified_items.append(FpRect(start  = new_coordinate_position(footprint.position, gitem.start, aux_data),
                                             end    = new_coordinate_position(footprint.position, gitem.end, aux_data),
                                             layer  = "F.SilkS",
                                             width  = gitem.width,
                                             stroke = None,
                                             fill   = gitem.fill,
                                             locked = False,
                                             tstamp = gitem.tstamp))

        elif isinstance(gitem, FpCircle):
            if (gitem.layer == "F.SilkS") or (gitem.layer == "B.SilkS"):
                if gitem.width < 0.1:
                    gitem.width = 0.1

                modified_items.append(FpCircle(center = new_coordinate_position(footprint.position, gitem.center, aux_data),
                                               end    = new_coordinate_position(footprint.position, gitem.end, aux_data),
                                               layer  = "F.SilkS",
                                               width  = gitem.width,
                                               stroke = None,
                                               fill   = gitem.fill,
                                               locked = False,
                                               tstamp = gitem.tstamp))

        elif isinstance(gitem, FpArc):
            if (gitem.layer == "F.SilkS") or (gitem.layer == "B.SilkS"):
                # There is an issue with arc when flipped. The arc is drawing clockwise so a normal arc becomes an inverse arc!
                # Therefor need to swap start and end.
                if aux_data.board_flip:  # flip
                    start = gitem.end
                    middle = gitem.mid
                    end = gitem.start

                else:  # no flip
                    start = gitem.start
                    middle = gitem.mid
                    end = gitem.end

                if gitem.width < 0.1:
                    gitem.width = 0.1

                new_start = Position(X        = pt_soff(start, aux_data.centroid_offset).X,
                                     Y        = pt_soff(start, aux_data.centroid_offset).Y * flipped(aux_data.board_flip),
                                     angle    = start.angle,
                                     unlocked = start.unlocked)

                new_mid   = Position(X        = pt_soff(middle, aux_data.centroid_offset).X,
                                     Y        = pt_soff(middle, aux_data.centroid_offset).Y * flipped(aux_data.board_flip),
                                     angle    = middle.angle,
                                     unlocked = middle.unlocked)

                new_end   = Position(X        = pt_soff(end, aux_data.centroid_offset).X,
                                     Y        = pt_soff(end, aux_data.centroid_offset).Y * flipped(aux_data.board_flip),
                                     angle    = end.angle,
                                     unlocked = end.unlocked)

                modified_items.append(FpArc(start  = new_coordinate_position(footprint.position, new_start, aux_data),
                                            mid    = new_coordinate_position(footprint.position, new_mid, aux_data),
                                            end    = new_coordinate_position(footprint.position, new_end, aux_data),
                                            layer  = "F.SilkS",
                                            width  = gitem.width,
                                            stroke = None,
                                            locked = False,
                                            tstamp = gitem.tstamp))

        elif isinstance(gitem, FpPoly):
            if (gitem.layer == "F.SilkS") or (gitem.layer == "B.SilkS"):
                if gitem.width < 0.1:
                    gitem.width = 0.1

                # Fab, Silkscreen and Courtyard Layers
                new_coords = list()

                for coord in gitem.coordinates:
                    new_coords.append(new_coordinate_position(footprint.position, coord, aux_data))

                modified_items.append(FpPoly(coordinates= new_coords,
                                             layer      = "F.SilkS",
                                             width      = gitem.width,
                                             stroke     = None,
                                             fill       = gitem.fill,
                                             locked     = False,
                                             tstamp     = gitem.tstamp))

        elif isinstance(gitem, FpCurve):
            if (gitem.layer == "F.SilkS") or (gitem.layer == "B.SilkS"):
                if gitem.width < 0.1:
                    gitem.width = 0.1

                new_coords = list()

                for coord in gitem.coordinates:
                    new_coords.append(new_coordinate_position(footprint.position, coord, aux_data))

                modified_items.append(FpCurve(coordinates = new_coords,
                                              layer       = "F.SilkS",
                                              width       = gitem.width,
                                              stroke      = None,
                                              locked      = False,
                                              tstamp      = gitem.tstamp))

    return modified_items


# ==================================================================================================================
# now add the models for the components select
def add_footprint_models(footprint, aux_data):
    modified_models = list()

    for model in footprint.models:
        new_path = model.path

        # We should look for the pointer to KiCAD library then Substitute "PinHeader" with "PinSocket" and vice-versa.
        # This will not work going forward without change!
        # For some we also need to swap "Right and Left"
        if new_path.find("${KICAD6_3DMODEL_DIR} / Connector_"):
            if new_path.find("PinHeader_") >= 0:
                new_path = new_path.replace("PinHeader_", "PinSocket_")
            elif new_path.find("PinSocket_") >= 0:
                new_path = new_path.replace("PinSocket_", "PinHeader_")

            if new_path.find("_Vertical_SMD_Pin1Right.") >= 0:
                new_path = new_path.replace("_Vertical_SMD_Pin1Right", "_Vertical_SMD_Pin1Left")
            elif new_path.find("_Vertical_SMD_Pin1Left.") >= 0:
                new_path = new_path.replace("_Vertical_SMD_Pin1Left", "_Vertical_SMD_Pin1Right")

        # TODO: else:
        # TODO:     # Not one of the libraries we can handle so need to copy file to the "Shapes_3D" directory.

        modified_models.append(new_model_position(footprint.position, model, new_path, aux_data.centroid_offset, aux_data.board_flip))

    return modified_models
